{
    "Graphs": [
        {
            "description": "Given a a directed graph and two nodes, write a method to determine if a path exists from the first to second.",
            "go": "package graphs\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Node is a member of a graph defined by the data it holds\n// and the links to other nodes\ntype Node struct {\n\tData int\n\tAdj  []*Node\n}\n\n// ToString produces a string representing a node and its adjacencies\nfunc (n *Node) ToString() string {\n\tss := []string{}\n\tfor _, node := range n.Adj {\n\t\tss = append(ss, strconv.Itoa(node.Data))\n\t}\n\treturn fmt.Sprintf(\"Data: %d | Edges: %s\", n.Data, strings.Join(ss, \", \"))\n}\n\n// PathExists determines if a path exists between two nodes in a graph\n// in O(n) time and space\nfunc PathExists(source, target *Node) bool {\n\tvisited := map[*Node]bool{}\n\tdfs(source, target, visited)\n\n\treturn visited[target]\n}\n\n// basic DFS implementation\nfunc dfs(node, target *Node, visited map[*Node]bool) {\n\tvisited[node] = true\n\tfor _, adj := range node.Adj {\n\t\tif visited[target] {\n\t\t\tbreak\n\t\t}\n\t\tif !visited[adj] {\n\t\t\tdfs(adj, target, visited)\n\t\t}\n\t}\n}\n",
            "number": "1",
            "python": "class Node:\n    def __init__(self, data=None):\n        self.data = data\n        self.neighbors = []\n\n    def __repr__(self):\n        return f'Data: {self.data} | Edges: {[neighbor.data for neighbor in self.neighbors]}'\n\n\n# O(n) in both space and time\ndef path_exists(source, target):\n    visited = set()\n    dfs(source, target, visited)\n\n    return target in visited\n\n\n# basic DFS implementation\ndef dfs(node, target, visited=set()):\n    visited.add(node)\n\n    for neighbor in node.neighbors:\n        # stop any additional recursion once the target is discovered\n        if target in visited:\n            break\n        if neighbor not in visited:\n            dfs(neighbor, target, visited)\n",
            "stem": "graphs_1",
            "title": "Path Existence",
            "ts": "export class Vertex {\n  data: number | string\n  adjacency: Vertex[]\n\n  constructor(data?: number | string) {\n    this.data = data\n    this.adjacency = []\n  }\n\n  toString(): string {\n    return `Data: ${this.data} | Edges: ${this.adjacency.map(n => n.data)}`\n  }\n}\n\n// O(n) time and space\nfunction pathExists(source: Vertex, target: Vertex): boolean {\n  const visited: Set<Vertex> = new Set()\n  dfs(source, target, visited)\n  return visited.has(target)\n}\n\nfunction dfs(node: Vertex, target: Vertex, visited: Set<Vertex>) {\n  visited.add(node)\n  for (const adj of node.adjacency) {\n    if (visited.has(target)) break\n    if (!visited.has(adj)) dfs(adj, target, visited)\n  }\n}\n"
        },
        {
            "description": "Given a list of projects and a list of dependencies find a valid build order. If there is no valid build order return an error.",
            "go": "package graphs\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// StringNode represents a node in the graph\ntype StringNode struct {\n\tData string\n\tAdj  []*StringNode\n}\n\n// ToString produces a string representing a node and its adjacencies\nfunc (n *StringNode) ToString() string {\n\tss := []string{}\n\tfor _, node := range n.Adj {\n\t\tss = append(ss, node.Data)\n\t}\n\treturn fmt.Sprintf(\"Data: %s | Edges: %s\", n.Data, strings.Join(ss, \", \"))\n}\n\n// Dependency encodes the blocker => project relation\ntype Dependency struct {\n\tBlocker string\n\tProject string\n}\n\n// O(p + d) where p is the number of projects and\n// d is the number of dependencies\nfunc buildGraph(projects []string, dependencies []Dependency) (map[string]*StringNode, map[string]bool, map[string]map[*StringNode]bool) {\n\tprojectNodes := map[string]*StringNode{}\n\troots := map[string]bool{}\n\tdependencyMap := map[string]map[*StringNode]bool{}\n\n\tfor _, project := range projects {\n\t\tprojectNodes[project] = &StringNode{Data: project}\n\t\troots[project] = true\n\t}\n\n\tfor _, dependency := range dependencies {\n\t\tif roots[dependency.Project] {\n\t\t\tdelete(roots, dependency.Project)\n\t\t}\n\n\t\tprojectNodes[dependency.Blocker].Adj = append(\n\t\t\tprojectNodes[dependency.Blocker].Adj,\n\t\t\tprojectNodes[dependency.Project],\n\t\t)\n\n\t\tif _, ok := dependencyMap[dependency.Project]; !ok {\n\t\t\tdependencyMap[dependency.Project] = map[*StringNode]bool{}\n\t\t}\n\n\t\tdependencyMap[dependency.Project][projectNodes[dependency.Blocker]] = true\n\t}\n\n\treturn projectNodes, roots, dependencyMap\n}\n\n// BuildSchedule runs in O(p + d)\nfunc BuildSchedule(projects []string, dependencies []Dependency) ([]string, error) {\n\tprojectNodes, roots, dependencyMap := buildGraph(projects, dependencies)\n\n\tschedule := []string{}\n\tvisited := map[*StringNode]bool{}\n\n\tfor root := range roots {\n\t\t// could be implemented in O(1)\n\t\t// using slices out of convenience\n\t\tschedule = append(schedule, walk(projectNodes[root], visited, dependencyMap)...)\n\n\t\tif len(schedule) == len(projectNodes) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif len(schedule) != len(projectNodes) {\n\t\treturn nil, errors.New(\"no viable path\")\n\t}\n\n\treturn schedule, nil\n}\n\n// O(p)\nfunc walk(node *StringNode, visited map[*StringNode]bool, dependencyMap map[string]map[*StringNode]bool) []string {\n\tif dependencies, ok := dependencyMap[node.Data]; ok {\n\t\tfor d := range dependencies {\n\t\t\tif !visited[d] {\n\t\t\t\treturn []string{}\n\t\t\t}\n\t\t}\n\t}\n\n\tvisited[node] = true\n\tschedule := []string{node.Data}\n\n\tfor _, adj := range node.Adj {\n\t\tif !visited[adj] {\n\t\t\tschedule = append(schedule, walk(adj, visited, dependencyMap)...)\n\t\t}\n\t}\n\n\treturn schedule\n}\n",
            "number": "2",
            "python": "from graphs_1 import Node\n\n# for Node class def see Path Existence\n\n\n# O(m) where m is the number of dependencies, which is O(n^2) where n is the number of nodes\n# create each Node instance defining the graph\n# return a set of roots,, where a root is a Node without any dependencies\n# dependencies: [(A, B), (C, D), ...] => B depends on A, D depends on C, and so on\n# for simplicity assume that a tuple is not repeated in this set\n# projects = [A, B, C, D, ...]\ndef build_graph(projects, dependencies):\n    project_nodes = {}\n\n    # O(n)\n    # will use this to figure out which projects have no dependencies\n    roots = set(projects)\n\n    # for every node we want a set of dependencies\n    # to know if the visitation constraint will be satisfied\n    dependency_map = {}\n\n    # O(n)\n    # ensure that project_nodes represents the complete set\n    for project in projects:\n        project_nodes[project] = Node(project)\n\n    # O(m)\n    for dependency, project in dependencies:\n        if project in roots:\n            roots.remove(project)\n\n        # add directed edge\n        project_nodes[dependency].neighbors.append(project_nodes[project])\n\n        # populate dependency map\n        if dependency_map.get(project):\n            dependency_map[project].add(project_nodes[dependency])\n        else:\n            dependency_map[project] = {project_nodes[dependency]}\n\n    return project_nodes, roots, dependency_map\n\n\n# O(m + n) || O(n^2) -- see comment above\ndef build_schedule(projects, dependencies):\n    project_nodes, roots, dependency_map = build_graph(projects, dependencies)\n\n    # would use a linked list for O(1) list extension\n    # using a built-in list for convenience\n    schedule = []\n    visited = set()\n\n    for root in roots:\n        schedule += walk(project_nodes[root], visited, dependency_map)\n\n        # viable schedule discovered\n        if len(schedule) == len(project_nodes):\n            break\n\n    # cycle detected\n    if len(schedule) != len(project_nodes):\n        raise Exception('no viable build order')\n\n    return schedule\n\n\n# O(n) DFS with the addition of a dependency_map to ensure that a node is visitable\ndef walk(node, visited, dependency_map):\n    if dependency_map.get(node.data):\n        # builds a boolean vector in O(n) and then folds it in O(n)\n        if not all([dependency in visited for dependency in dependency_map.get(node.data)]):\n            return []\n\n    visited.add(node)\n    schedule = [node.data]\n\n    # only touching each node once O(n)\n    for neighbor in node.neighbors:\n        if neighbor not in visited:\n            # technically list concatnation as the stack unwinds is O(n^2)\n            # but, this could've been implemented using linked lists\n            # since we have no need for random index access\n            # which would keep the time complexity at O(n)\n            schedule += walk(neighbor, visited, dependency_map)\n\n    return schedule\n",
            "stem": "graphs_2",
            "title": "Build Order",
            "ts": "import { Vertex } from './graphs_1'\n\ninterface Dependency {\n  blocker: string\n  project: string\n}\n\ninterface GraphData {\n  projectVertices: { [key: string]: Vertex }\n  roots: Set<Vertex>\n  dependencyMap: { [key: string]: Vertex[] }\n}\n\n// O(p + d)\nfunction buildGraph(projects: string[], dependencies: Dependency[]): GraphData {\n  const projectVertices: { [key: string]: Vertex } = {}\n  const roots: Set<Vertex> = new Set()\n  const dependencyMap: { [key: string]: Vertex[] } = {}\n\n  projects.forEach(p => {\n    const vertex = new Vertex(p)\n    projectVertices[p] = vertex\n    roots.add(vertex)\n  })\n\n  dependencies.forEach(({ blocker, project }) => {\n    roots.delete(projectVertices[project])\n\n    projectVertices[blocker].adjacency.push(projectVertices[project])\n\n    if (dependencyMap[project]) {\n      dependencyMap[project].push(projectVertices[blocker])\n    } else {\n      dependencyMap[project] = [projectVertices[blocker]]\n    }\n  })\n\n  return {\n    projectVertices,\n    roots,\n    dependencyMap,\n  }\n}\n\nfunction buildSchedule(\n  projects: string[],\n  dependencies: Dependency[],\n): string[] {\n  const { projectVertices, roots, dependencyMap } = buildGraph(\n    projects,\n    dependencies,\n  )\n\n  const schedule: string[] = []\n  const visited: Set<Vertex> = new Set()\n  const numVertices = Object.keys(projectVertices).length\n\n  for (const r of roots) {\n    schedule.push(...walk(projectVertices[r.data], visited, dependencyMap))\n\n    if (schedule.length === numVertices) {\n      break\n    }\n  }\n\n  if (schedule.length !== numVertices) {\n    throw 'no viable path'\n  }\n\n  return schedule\n}\n\nfunction walk(\n  vertex: Vertex,\n  visited: Set<Vertex>,\n  dependencyMap: { [key: string]: Vertex[] },\n): string[] {\n  if (\n    dependencyMap[vertex.data] &&\n    !dependencyMap[vertex.data].every(v => visited.has(v))\n  ) {\n    return []\n  }\n\n  visited.add(vertex)\n  // '' + is a type assertion so that\n  // we don't have to define Vertex more than once\n  // generally this is not necessary\n  const schedule: string[] = ['' + vertex.data]\n\n  for (const v of vertex.adjacency) {\n    if (!visited.has(v)) {\n      schedule.push(...walk(v, visited, dependencyMap))\n    }\n  }\n\n  return schedule\n}\n"
        }
    ],
    "Linked Lists": [
        {
            "description": "Write a method to remove duplicates from an unsorted linked list. As a follow up write a method that does so without any additional memory allocation like storing the seen values in a hash table.",
            "go": "package linked\n\nimport \"fmt\"\n\n// Node is a node in a linked list\n// value could be any datatype, but Go does not support generics\ntype Node struct {\n\tValue int\n\tNext  *Node\n}\n\n// List wraps a head node\ntype List struct {\n\tHead *Node\n}\n\n// ToString prints a linked list\nfunc (l List) ToString() string {\n\ts := \"\"\n\tnode := l.Head\n\tfor node != nil {\n\t\ts = s + fmt.Sprintf(\"%d -> \", node.Value)\n\t\tnode = node.Next\n\t}\n\treturn s + \"nil\"\n}\n\n// RemoveDuplicatesTime runs in O(n)\nfunc RemoveDuplicatesTime(l List) {\n\tvalueSet := map[int]bool{}\n\tnode := l.Head\n\n\tfor node.Next != nil {\n\t\tif valueSet[node.Next.Value] {\n\t\t\tnode.Next = node.Next.Next\n\t\t} else {\n\t\t\tvalueSet[node.Next.Value] = true\n\t\t\tnode = node.Next\n\t\t}\n\t}\n}\n\n// RemoveDuplicatesSpace runs in O(1) space -- O(n^2) time\nfunc RemoveDuplicatesSpace(l List) {\n\tindexNode := l.Head\n\tvar cursorNode *Node\n\n\tfor indexNode.Next != nil {\n\t\tcursorNode = indexNode\n\t\tfor cursorNode.Next != nil {\n\t\t\tif cursorNode.Next.Value == indexNode.Value {\n\t\t\t\tcursorNode.Next = cursorNode.Next.Next\n\t\t\t} else {\n\t\t\t\tcursorNode = cursorNode.Next\n\t\t\t}\n\t\t}\n\t\tindexNode = indexNode.Next\n\t}\n}\n",
            "number": "1",
            "python": "class LinkedList:\n    def __init__(self, head):\n        self.head = head\n\n    def __repr__(self):\n        node = self.head\n        nodes = []\n        while node:\n            nodes.append(str(node.value))\n            node = node.next\n        return ' -> '.join(nodes + ['None'])\n\n\nclass Node:\n    def __init__(self, value, next):\n        self.value = value\n        self.next = next\n\n    def __repr__(self):\n        return str(self.value)\n\n\n# O(n)\ndef remove_duplicates_time(linked_list):\n    values = set()\n    node = linked_list.head\n\n    while node.next:\n        if node.next.value in values:\n            node.next = node.next.next\n        else:\n            values.add(node.next.value)\n            node = node.next\n\n\n# O(1) space -- O(n^2) time\ndef remove_duplicates_space(linked_list):\n    index_node = linked_list.head\n\n    while index_node.next:\n        cursor_node = index_node\n        while cursor_node.next:\n            if cursor_node.next.value == index_node.value:\n                cursor_node.next = cursor_node.next.next\n            else:\n                cursor_node = cursor_node.next\n        index_node = index_node.next\n",
            "stem": "linked_1",
            "title": "Remove Duplicates",
            "ts": "// Node already exists in JS\nexport class Node_ {\n  value: number\n  next: Node_\n\n  constructor(value: number, next: Node_) {\n    this.value = value\n    this.next = next\n  }\n}\n\nexport class LinkedList {\n  head: Node_\n\n  constructor(head: Node_) {\n    this.head = head\n  }\n\n  toString() {\n    let s = ''\n    let node = this.head\n    while (node) {\n      s = `${s}${node.value} -> `\n      node = node.next\n    }\n    return s + 'nil'\n  }\n}\n\n// O(n)\nfunction removeDuplicatesTime(l: LinkedList) {\n  const valueSet: Set<number> = new Set()\n  let node = l.head\n\n  while (node.next) {\n    if (valueSet.has(node.next.value)) {\n      node.next = node.next.next\n    } else {\n      valueSet.add(node.next.value)\n      node = node.next\n    }\n  }\n}\n\n// O(1) space -- O(n^2) time\nfunction removeDuplicatesSpace(l: LinkedList) {\n  let indexNode = l.head\n  let cursorNode\n\n  while (indexNode.next) {\n    cursorNode = indexNode\n    while (cursorNode.next) {\n      if (cursorNode.next.value === indexNode.value) {\n        cursorNode.next = cursorNode.next.next\n      } else {\n        cursorNode = cursorNode.next\n      }\n    }\n    indexNode = indexNode.next\n  }\n}\n"
        },
        {
            "description": "Write a method to find the kth to last element of singly linked list.",
            "go": "package linked\n\nimport \"fmt\"\n\n// see Remove Duplicates for List and Node type definitions\n\n// KthToLastElement runs in O(n)\nfunc KthToLastElement(l List, k int) *Node {\n\tleadNode := l.Head\n\tlagNode := l.Head\n\tleadIndex := 0\n\tlagIndex := 0\n\n\tfor leadNode != nil {\n\t\tleadNode = leadNode.Next\n\t\tleadIndex++\n\t\tif leadIndex > k {\n\t\t\tlagNode = lagNode.Next\n\t\t\tlagIndex++\n\t\t}\n\t}\n\n\tif leadIndex-lagIndex < k {\n\t\tfmt.Printf(\"List is not long enough to have a %d(st/nd/rd/th) to last element, returning the first node instead.\\n\", k)\n\t}\n\n\treturn lagNode\n}\n",
            "number": "2",
            "python": "# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef kth_to_last_element(linked_list, k):\n    # maintain a leading and lagging pointer\n    # lag will trail the lead by k\n    lead_node = linked_list.head\n    lag_node = linked_list.head\n    lead_index = 0\n    lag_index = 0\n\n    while lead_node:\n        lead_node = lead_node.next\n        lead_index += 1\n        if lead_index > k:\n            lag_node = lag_node.next\n            lag_index += 1\n\n    if lead_index - lag_index < k:\n        print('List is not long enough to have a %d(st/nd/rd/th) to last element, returning the first node instead.')\n\n    return lag_node\n",
            "stem": "linked_2",
            "title": "Kth to Last",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(n)\nfunction kthToLastElement(l: LinkedList, k: number): Node_ {\n  let leadNode: Node_ = l.head\n  let lagNode: Node_ = l.head\n  let leadIndex = 0\n  let lagIndex = 0\n\n  while (leadNode) {\n    leadNode = leadNode.next\n    leadIndex++\n    if (leadIndex > k) {\n      lagNode = lagNode.next\n      lagIndex++\n    }\n  }\n\n  if (leadIndex - lagIndex < k) {\n    console.log(\n      `List is not long enough to have a ${k}(st/nd/rd/th) to last element, returning the first node instead.`,\n    )\n  }\n\n  return lagNode\n}\n"
        },
        {
            "description": "Given a pointer to a node appearing somewhere in a linked list write a method to remove it. Assume no access to the head of the list and the element being removed is not the first or last element.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n\n// DeleteNode is O(1) -- see Python for comments\nfunc DeleteNode(n *Node) {\n\tn.Value = n.Next.Value\n\tn.Next = n.Next.Next\n}\n",
            "number": "3",
            "python": "# see Remove Duplicates for List and Node type definitions\n\n\n# O(1)\ndef delete_node(node):\n    # overwrite the value of this node with the next node\n    # then splice out the next node to remove the duplicate data\n\n    # assert that node.next exists from the problem statement\n    node.value = node.next.value\n    node.next = node.next.next\n\n    # note that this does not remove the reference to the node\n    # in fact it removes the reference to the next node\n    # it only ensures that the data in the list reflects the delete\n",
            "stem": "linked_3",
            "title": "Delete Node",
            "ts": "import { Node_ } from './linked_1'\n\n// O(1) -- see Python for comments\nfunction deleteNode(n: Node_) {\n  n.value = n.next.value\n  n.next = n.next.next\n}\n"
        },
        {
            "description": "Write method to generate a partitioned linked list from an input list and value such that all elements greater than or equal to the value appear after elements that are less than the value. Ordering does not matter, e.g. 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 with a supplied value of 5 outputs 3 -> 1 -> -> 2 -> 10 -> 5 -> 5 -> 8 where the partition exists between 2 and 10.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n\n// Partition runs in O(n)\nfunc Partition(l List, value int) *Node {\n\thead := l.Head\n\ttail := l.Head\n\tnode := l.Head\n\n\tfor node != nil {\n\t\tnext := node.Next\n\n\t\tif node.Value < value {\n\t\t\tnode.Next = head\n\t\t\thead = node\n\t\t} else {\n\t\t\ttail.Next = node\n\t\t\ttail = node\n\t\t}\n\n\t\tnode = next\n\t}\n\n\ttail.Next = nil\n\n\treturn head\n}\n",
            "number": "4",
            "python": "# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef partition(list, value):\n    head = list.head\n    tail = list.head\n    node = list.head\n\n    # O(n)\n    while node:\n        # keep a reference to the next node in the original list\n        next = node.next\n\n        if node.value < value:\n            # reassign node to point at the previous head\n            node.next = head\n            # reassign the head of the list to this node\n            head = node\n        else:\n            # push this node on to the end of the list\n            tail.next = node\n            # reassign the tail to this node\n            tail = node\n\n        # move on to the next node in the original list\n        node = next\n\n    # clip the tail\n    tail.next = None\n\n    return head\n",
            "stem": "linked_4",
            "title": "Partition",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(n)\nfunction partition(l: LinkedList, value: number): Node_ {\n  let head: Node_ = l.head\n  let tail: Node_ = l.head\n  let node: Node_ = l.head\n\n  while (node) {\n    const next = node.next\n\n    if (node.value < value) {\n      node.next = head\n      head = node\n    } else {\n      tail.next = node\n      tail = node\n    }\n\n    node = next\n  }\n\n  tail.next = null\n\n  return head\n}\n"
        },
        {
            "description": "Given two numbers represented by linked lists where each number is a digit. Produce the sum of these numbers a new linked list. Generate one method that handles right to left ordering: 6 -> 1 -> 7 => 716 and one that handles left to right ordering 6 -> 1 -> 7 => 617.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n\n// Stack implements a LIFO data structure\ntype Stack struct {\n\tns []*Node\n}\n\n// RightToLeftSum is O(m + n)\nfunc RightToLeftSum(l1, l2 List) List {\n\tn1 := l1.Head\n\tn2 := l2.Head\n\t// assumes length of each list is at least 1\n\tnextValue := n1.Value + n2.Value\n\tsumNode := &Node{Value: nextValue % 10, Next: nil}\n\tsumList := List{Head: sumNode}\n\tcarry := nextValue / 10\n\n\tfor n1.Next != nil || n2.Next != nil {\n\t\tif n1.Next == nil {\n\t\t\tnextValue = n2.Next.Value + carry\n\t\t\tn2 = n2.Next\n\t\t} else if n2.Next == nil {\n\t\t\tnextValue = n1.Next.Value + carry\n\t\t\tn1 = n1.Next\n\t\t} else {\n\t\t\tnextValue = n1.Next.Value + n2.Next.Value + carry\n\t\t\tn1 = n1.Next\n\t\t\tn2 = n2.Next\n\t\t}\n\n\t\tcarry = nextValue / 10\n\t\tsumNode.Next = &Node{Value: nextValue % 10, Next: nil}\n\t\tsumNode = sumNode.Next\n\t}\n\n\tif carry == 1 {\n\t\tsumNode.Next = &Node{Value: 1, Next: nil}\n\t}\n\n\treturn sumList\n}\n\n// ListToStack is O(n)\nfunc (l List) ListToStack() Stack {\n\tstack := Stack{}\n\tnode := l.Head\n\tfor node != nil {\n\t\tstack.ns = append(stack.ns, node)\n\t\tnode = node.Next\n\t}\n\treturn stack\n}\n\n// for both stack methods it is important to pass by reference (*Stack)\n\n// Len is O(1)\nfunc (s *Stack) Len() int {\n\treturn len(s.ns)\n}\n\n// Pop is O(1)\nfunc (s *Stack) Pop() *Node {\n\tnode := s.ns[len(s.ns)-1]\n\ts.ns = s.ns[0 : len(s.ns)-1]\n\treturn node\n}\n\n// LeftToRightSum is O(m + n)\nfunc LeftToRightSum(l1, l2 List) List {\n\tstack1 := l1.ListToStack()\n\tstack2 := l2.ListToStack()\n\n\tvar head *Node\n\tvar node *Node\n\tvar nextValue int\n\tcarry := 0\n\n\tfor stack1.Len() > 0 || stack2.Len() > 0 {\n\t\tif stack1.Len() == 0 {\n\t\t\tnode = stack2.Pop()\n\t\t\tnextValue = node.Value + carry\n\t\t\tnode.Value = nextValue % 10\n\t\t\tnode.Next = head\n\t\t} else if stack2.Len() == 0 {\n\t\t\tnode = stack1.Pop()\n\t\t\tnextValue = node.Value + carry\n\t\t\tnode.Value = nextValue % 10\n\t\t\tnode.Next = head\n\t\t} else {\n\t\t\tnode1 := stack1.Pop()\n\t\t\tnode2 := stack2.Pop()\n\t\t\tnextValue = node1.Value + node2.Value + carry\n\t\t\tnode = &Node{Value: nextValue % 10, Next: head}\n\t\t}\n\n\t\tcarry = nextValue / 10\n\t\thead = node\n\t}\n\n\tif carry == 1 {\n\t\tnode := &Node{Value: 1, Next: head}\n\t\thead = node\n\t}\n\n\treturn List{Head: head}\n}\n",
            "number": "5",
            "python": "from linked_lists_1 import LinkedList, Node\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(m + n)\ndef right_to_left_sum(l1, l2):\n    # step through the lists at the same time performing addition\n    # and carrying the one as needed\n    n1 = l1.head\n    n2 = l2.head\n    # assumes length of each list is at least 1\n    next_value = n1.value + n2.value\n    carry = next_value // 10\n    sum_node = Node(next_value % 10, None)\n    sum_list = LinkedList(sum_node)\n\n    # O(m + n)\n    while n1.next or n2.next:\n        if not n1.next:\n            next_value = n2.next.value + carry\n        elif not n2.next:\n            next_value = n1.next.value + carry\n        else:\n            next_value = n1.next.value + n2.next.value + carry\n\n        carry = next_value // 10\n\n        sum_node.next = Node(next_value % 10, None)\n        sum_node = sum_node.next\n\n        n1 = n1.next if n1.next else n1\n        n2 = n2.next if n2.next else n2\n\n    if carry == 1:\n        sum_node.next = Node(1, None)\n\n    return sum_list\n\n\n# O(n)\ndef list_to_stack(l):\n    stack = []\n    node = l.head\n    while node:\n        stack.append(node)\n        node = node.next\n\n    return stack\n\n\n# O(m + n)\ndef left_to_right_sum(l1, l2):\n    # O(n)\n    stack1 = list_to_stack(l1)\n    # O(m)\n    stack2 = list_to_stack(l2)\n\n    head = None\n    carry = 0\n\n    # O(m + n)\n    while stack1 or stack2:\n        if not stack1:\n            node = stack2.pop()\n            next_value = node.value + carry\n            node.value = next_value % 10\n            node.next = head\n        elif not stack2:\n            node = stack1.pop()\n            next_value = node.value + carry\n            node.value = next_value % 10\n            node.next = head\n        else:\n            node1 = stack1.pop()\n            node2 = stack2.pop()\n            next_value = node1.value + node2.value + carry\n            node = Node(next_value % 10, head)\n\n        carry = next_value // 10\n        head = node\n\n    if carry == 1:\n        node = Node(1, head)\n        head = node\n\n    return LinkedList(head)\n",
            "stem": "linked_5",
            "title": "Sum Lists",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(m + n)\nfunction rightToLeftSum(l1: LinkedList, l2: LinkedList): LinkedList {\n  let n1: Node_ = l1.head\n  let n2: Node_ = l2.head\n  let nextValue = n1.value + n2.value\n  let sumNode = new Node_(nextValue % 10, null)\n  const sumList = new LinkedList(sumNode)\n  let carry = Math.floor(nextValue / 10)\n\n  while (n1.next || n2.next) {\n    if (!n1.next) {\n      nextValue = n2.next.value + carry\n      n2 = n2.next\n    } else if (!n2.next) {\n      nextValue = n1.next.value + carry\n      n1 = n1.next\n    } else {\n      nextValue = n1.next.value + n2.next.value + carry\n      n1 = n1.next\n      n2 = n2.next\n    }\n\n    carry = Math.floor(nextValue / 10)\n    sumNode.next = new Node_(nextValue % 10, null)\n    sumNode = sumNode.next\n  }\n\n  if (carry === 1) {\n    sumNode.next = new Node_(1, null)\n  }\n\n  return sumList\n}\n\n// O(n)\nfunction listToStack(l: LinkedList): Node_[] {\n  const stack: Node_[] = []\n  let node = l.head\n  while (node) {\n    stack.push(node)\n    node = node.next\n  }\n  return stack\n}\n\n// O(m + n)\nfunction leftToRightSum(l1: LinkedList, l2: LinkedList): LinkedList {\n  const stack1 = listToStack(l1)\n  const stack2 = listToStack(l2)\n  let head: Node_\n  let node: Node_\n  let nextValue\n  let carry = 0\n\n  while (stack1.length > 0 || stack2.length > 0) {\n    if (stack1.length === 0) {\n      node = stack2.pop()\n      nextValue = node.value + carry\n      node.value = nextValue % 10\n      node.next = head\n    } else if (stack2.length === 0) {\n      node = stack1.pop()\n      nextValue = node.value + carry\n      node.value = nextValue % 10\n      node.next = head\n    } else {\n      const node1 = stack1.pop()\n      const node2 = stack2.pop()\n      nextValue = node1.value + node2.value + carry\n      node = new Node_(nextValue % 10, head)\n    }\n\n    carry = Math.floor(nextValue / 10)\n    head = node\n  }\n\n  if (carry === 1) {\n    node = new Node_(1, head)\n    head = node\n  }\n\n  return new LinkedList(head)\n}\n"
        },
        {
            "description": "Write a method to determine if a linked list is a palindrome.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n// see Sum Lists for stack type definition and methods\n\n// IsPalindrome is O(n)\nfunc IsPalindrome(l List) bool {\n\tlistNode := l.Head\n\tstack := l.ListToStack()\n\tlistLength := stack.Len()\n\n\tfor stack.Len() >= listLength/2 {\n\t\tstackNode := stack.Pop()\n\t\tif stackNode.Value != listNode.Value {\n\t\t\treturn false\n\t\t}\n\t\tlistNode = listNode.Next\n\t}\n\n\treturn true\n}\n",
            "number": "6",
            "python": "from linked_lists_1 import LinkedList, Node\n\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef list_to_stack(l):\n    stack = []\n    node = l.head\n\n    while node:\n        stack.append(node)\n        node = node.next\n\n    return stack\n\n\n# O(n)\ndef is_palindrome(l):\n    list_node = l.head\n    # O(n) create a stack to represent the list in reverse order\n    stack = list_to_stack(l)\n    list_length = len(stack)\n\n    # O(n) compare the stack to the list\n    while len(stack) >= list_length // 2:\n        stack_node = stack.pop()\n        if stack_node.value != list_node.value:\n            return False\n        list_node = list_node.next\n\n    return True\n",
            "stem": "linked_6",
            "title": "Palindrome",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(n)\nfunction listToStack(l: LinkedList): Node_[] {\n  const stack: Node_[] = []\n  let node = l.head\n  while (node) {\n    stack.push(node)\n    node = node.next\n  }\n  return stack\n}\n\n// O(n)\nfunction isPalindrome(l: LinkedList): boolean {\n  let listNode: Node_ = l.head\n  const stack = listToStack(l)\n  const listLength = stack.length\n\n  while (stack.length >= Math.floor(listLength / 2)) {\n    const stackNode = stack.pop()\n    if (stackNode.value !== listNode.value) {\n      return false\n    }\n    listNode = listNode.next\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Given two singly linked list determine if they share a node (by reference). If the lists intersect return the intersecting node.",
            "go": "package linked\n\n// FindIntersection is O(m + n)\nfunc FindIntersection(l1, l2 List) *Node {\n\tm := map[*Node]bool{}\n\n\tnode := l1.Head\n\tfor node != nil {\n\t\tm[node] = true\n\t\tnode = node.Next\n\t}\n\n\tnode = l2.Head\n\tfor node != nil {\n\t\tif m[node] {\n\t\t\treturn node\n\t\t}\n\t\tnode = node.Next\n\t}\n\n\treturn nil\n}\n",
            "number": "7",
            "python": "from linked_lists_1 import LinkedList, Node\n\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(m + n) time -- requires additional space for the set\ndef find_intersection(l1, l2):\n    # could do this in O(m + n) without the set\n    # by traversing to determine length of each and if the tail nodes are the same\n    # then traverse both lists starting at the difference between the lengths for the longer list\n    # effectively have the same distance between the tail and the starting point for each list\n    # compare each next node and the first node that is the same is the intersection\n\n    list1_nodes = set()\n\n    node = l1.head\n    while node:\n        list1_nodes.add(node)\n        node = node.next\n\n    node = l2.head\n    while node:\n        if node in list1_nodes:\n            return node\n        node = node.next\n",
            "stem": "linked_7",
            "title": "Intersection",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(m + n)\nfunction findIntersection(l1: LinkedList, l2: LinkedList): Node_ {\n  const nodeSet: Set<Node_> = new Set()\n\n  let node = l1.head\n  while (node) {\n    nodeSet.add(node)\n    node = node.next\n  }\n\n  node = l2.head\n  while (node) {\n    if (nodeSet.has(node)) {\n      return node\n    }\n    node = node.next\n  }\n\n  return null\n}\n"
        },
        {
            "description": "Given a linked list that loops back on itself, implement an algorithm that returns the node at the beginning of the loop. Next, as a more difficult task implement an algorithm that only relies on references to nodes and does not rely on any state outside of the linked list.",
            "go": "package linked\n\n// FindLoopStart is O(n)\nfunc FindLoopStart(l List) *Node {\n\tm := map[*Node]bool{}\n\tnode := l.Head\n\n\tfor node != nil {\n\t\tif m[node] {\n\t\t\treturn node\n\t\t}\n\t\tm[node] = true\n\t\tnode = node.Next\n\t}\n\n\treturn nil\n}\n\n// FindLoopStartHard is O(n)\n// see comments in Python solution\nfunc FindLoopStartHard(l List) *Node {\n\tfast := l.Head\n\tslow := l.Head\n\n\tfast = fast.Next.Next\n\tslow = slow.Next\n\n\tfor fast != slow {\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t}\n\n\tslow = l.Head\n\n\tfor fast != slow {\n\t\tfast = fast.Next\n\t\tslow = slow.Next\n\t}\n\n\treturn fast\n}\n",
            "number": "8",
            "python": "from linked_lists_1 import LinkedList, Node\n\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef find_loop_start(l):\n    visited = set()\n    node = l.head\n    while node:\n        if node in visited:\n            return node\n        visited.add(node)\n        node = node.next\n\n\n# let k be the distance between head and the start of the loop\n# let s be a slow pointer that moves one node every step\n# let f be a fast pointer that moves two nodes every step\n# let l be the length of the loop\n\n# when s has moved k and enters the loop\n# f is k steps into the loop, since it moved a distance of 2k\n# since the loop is a circular path and we know nothing about the length of the loop\n# compared to the distance between the head and the start of the loop\n# f is actually a distance k % l past the start of the loop when s gets there\n# having gone around the loop 0 or more times\n\n# let K = k % l\n# once both pointers are in the loop f gets 1 node closer to s every step\n# f is l - K steps behind s and the two will collide after exactly l - K steps\n# since s was at the start of the loop we can equivalently say that they will\n# collide at a distance of K from the start of the loop\n\n# since K = k % l, we can represent this as K + m * l = k for any integer m\n# since 1 degree on a circle is the same position as 361 degrees on a circle\n# we can say that a distance of K from the start is the same as a distance of k\n\n# knowing that the collision point is a k nodes back from the start of the loop\n# and k nodes from the head of the list we can traverse two pointers\n# one from head and the other from the node at which f and s collided\n# the node at which these two pointers collide must be the start of the loop\n\ndef find_loop_start_hard(l):\n    fast = l.head\n    slow = l.head\n\n    # take the first step (i.e. do while)\n    fast = fast.next.next\n    slow = slow.next\n\n    # \"is\" provides memory reference equivalence\n    while fast is not slow:\n        fast = fast.next.next\n        slow = slow.next\n\n    head_cursor = l.head\n    collision_cursor = fast\n\n    while head_cursor is not collision_cursor:\n        head_cursor = head_cursor.next\n        collision_cursor = collision_cursor.next\n\n    return head_cursor\n",
            "stem": "linked_8",
            "title": "Loop Detection",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// findLoopStart is O(n)\nfunction findLoopStart(l: LinkedList): Node_ {\n  const visited: Set<Node_> = new Set()\n  let node = l.head\n\n  while (node) {\n    if (visited.has(node)) {\n      return node\n    }\n    visited.add(node)\n    node = node.next\n  }\n}\n\n// findLoopStartHard is O(n)\n// see comments in Python solution\nfunction findLoopStartHard(l: LinkedList): Node_ {\n  let fast = l.head\n  let slow = l.head\n\n  fast = fast.next.next\n  slow = slow.next\n\n  while (fast !== slow) {\n    fast = fast.next.next\n    slow = slow.next\n  }\n\n  slow = l.head\n\n  while (fast !== slow) {\n    fast = fast.next\n    slow = slow.next\n  }\n\n  return fast\n}\n"
        }
    ],
    "Matrices": [
        {
            "description": "Given an image represented by an NxN matrix where each pixel is encoded as an integer, write a method to perform a 90 degree rotation in place (i.e. do not create a new matrix).",
            "go": "package iterables\n\n// RotateMatrix runs in O(n^2)\nfunc RotateMatrix(m [][]int) {\n\tfor i := 0; i < len(m)/2; i++ {\n\t\tfor j := i; j < len(m)-i-1; j++ {\n\t\t\t// slices are pointers to underlying arrays\n\t\t\t// so while everything is Go is pass by value, this is already\n\t\t\t// a reference and the modifications will occur in place\n\t\t\trotateCell(m, m[i][j], [2]int{j, len(m) - i - 1}, [2]int{i, j})\n\t\t}\n\t}\n}\n\nfunc rotateCell(m [][]int, value int, destination, start [2]int) {\n\tpreviousValue := m[destination[0]][destination[1]]\n\tm[destination[0]][destination[1]] = value\n\n\t// base case\n\tif destination[0] == start[0] && destination[1] == start[1] {\n\t\treturn\n\t}\n\n\trotateCell(m, previousValue, [2]int{destination[1], len(m) - destination[0] - 1}, start)\n}\n",
            "number": "1",
            "python": "# O(n^2) for an n x n matrix\ndef rotate_matrix(m):\n    # given a cell (i, j) the destination cell is (j, n - i - 1) for an n x n matrix\n\n    # assume m is represented by a 2D list of integers\n    # nested for loop is O(n^2)\n    # in this loop \"i\" represents the layer\n    # in an n x n matrix there are floor(n / 2) layers to rotate\n    for i in range(len(m) // 2):\n        for j in range(i, len(m) - i - 1):\n            # results in 4 recursive calls\n            rotate_cell(m, m[i][j], (j, len(m) - i - 1), (i, j))\n\n\n# rotate_cell is a recursive helper that sets the value of\n# of the destination cell to the supplied value\n# rotate_cell will be called 4 times before destination == start\ndef rotate_cell(m, value, destination, start):\n    previous_value = m[destination[0]][destination[1]]\n    m[destination[0]][destination[1]] = value\n\n    # base case\n    if destination == start:\n        return\n\n    rotate_cell(m, previous_value,\n                (destination[1], len(m) - destination[0] - 1), start)\n",
            "stem": "matrices_1",
            "title": "Matrix Rotation",
            "ts": "// O(n^2)\nfunction rotateMatrix(m: number[][]) {\n  // nested loop is O(n^2)\n  for (let i = 0; i < Math.floor(m.length / 2); i++) {\n    for (let j = i; j < m.length - i - 1; j++) {\n      rotateCell(m, m[i][j], [j, m.length - i - 1], [i, j])\n    }\n  }\n}\n\n// O(1) for each rotation with 4 recursive calls\nfunction rotateCell(\n  m: number[][],\n  value: number,\n  destination: number[],\n  start: number[],\n) {\n  const previousValue = m[destination[0]][destination[1]]\n  m[destination[0]][destination[1]] = value\n\n  if (destination[0] === start[0] && destination[1] === start[1]) {\n    return\n  }\n\n  rotateCell(\n    m,\n    previousValue,\n    [destination[1], m.length - destination[0] - 1],\n    start,\n  )\n}\n"
        },
        {
            "description": "Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.",
            "go": "package iterables\n\n// ZeroMatrix runs in O(nm)\nfunc ZeroMatrix(m [][]int) {\n\tzeroRows := map[int]bool{}\n\tzeroColumns := map[int]bool{}\n\n\tfor i := 0; i < len(m); i++ {\n\t\tfor j := 0; j < len(m[0]); j++ {\n\t\t\tif m[i][j] == 0 {\n\t\t\t\tzeroRows[i] = true\n\t\t\t\tzeroColumns[j] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := 0; i < len(m); i++ {\n\t\tfor j := 0; j < len(m[0]); j++ {\n\t\t\tif zeroRows[i] || zeroRows[j] {\n\t\t\t\tm[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n}\n",
            "number": "2",
            "python": "# O(mn) where m and n are the dimensions of the matrix\ndef zero_matrix(m):\n    zero_rows = set()\n    zero_columns = set()\n\n    # O(mn)\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            if m[i][j] == 0:\n                zero_rows.add(i)\n                zero_columns.add(j)\n    # O(mn)\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            # O(1) lookup by using sets\n            if i in zero_rows or j in zero_columns:\n                m[i][j] = 0\n",
            "stem": "matrices_2",
            "title": "Zero Matrix",
            "ts": "// O(mn)\nfunction zeroMatrix(m: number[][]) {\n  const zeroRows: Set<number> = new Set()\n  const zeroColumns: Set<number> = new Set()\n\n  for (let i = 0; i < m.length; i++) {\n    for (let j = 0; j < m[0].length; j++) {\n      if (m[i][j] === 0) {\n        zeroRows.add(i)\n        zeroColumns.add(j)\n      }\n    }\n  }\n\n  for (let i = 0; i < m.length; i++) {\n    for (let j = 0; j < m[0].length; j++) {\n      if (zeroRows.has(i) || zeroColumns.has(j)) {\n        m[i][j] = 0\n      }\n    }\n  }\n}\n"
        }
    ],
    "Stacks": [
        {
            "description": "Implement a stack that provides push, pop, and min in O(1).",
            "go": "package stacks\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// MinStack is LIFO data structure\n// supporting O(1) push, pop, and min\ntype MinStack struct {\n\tTop      *MinFrame\n\tMinFrame *MinFrame\n}\n\n// ToString provides a string representation for a stack\nfunc (s *MinStack) ToString() string {\n\tframes := []string{}\n\ttop := s.Top\n\n\tfor top != nil {\n\t\tframes = append(frames, top.ToString())\n\t\ttop = top.Next\n\t}\n\n\tif len(frames) > 0 {\n\t\tss := []string{\"top\"}\n\t\tss = append(ss, frames...)\n\t\tss = append(ss, \"bottom\")\n\t\tmin := \"None\"\n\n\t\tif s.MinFrame != nil {\n\t\t\tmin = strconv.Itoa(s.MinFrame.Data)\n\t\t} else {\n\t\t\tmin = \"nil\"\n\t\t}\n\n\t\treturn fmt.Sprintf(\"%s; Min: %s\", strings.Join(ss, \" -> \"), min)\n\t}\n\n\treturn \"empty stack\"\n}\n\n// Push O(1)\nfunc (s *MinStack) Push(data int) {\n\tframe := &MinFrame{Data: data, Next: s.Top}\n\n\tif s.MinFrame != nil {\n\t\tif data < s.MinFrame.Data {\n\t\t\tframe.PreviousMinFrame = s.MinFrame\n\t\t\ts.MinFrame = frame\n\t\t}\n\t} else {\n\t\ts.MinFrame = frame\n\t}\n\n\ts.Top = frame\n}\n\n// Pop O(1)\nfunc (s *MinStack) Pop() int {\n\tif s.Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\tif s.Top == s.MinFrame {\n\t\ts.MinFrame = s.Top.PreviousMinFrame\n\t}\n\n\tframe := s.Top\n\ts.Top = s.Top.Next\n\n\treturn frame.Data\n}\n\n// Min O(1)\nfunc (s *MinStack) Min() int {\n\tif s.Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\treturn s.MinFrame.Data\n}\n\n// MinFrame represents a single stack frame for a MinStack\n// using int for the data type out of convenience\ntype MinFrame struct {\n\tData             int\n\tNext             *MinFrame\n\tPreviousMinFrame *MinFrame\n}\n\n// ToString provides a string representation for a stack frame\nfunc (f *MinFrame) ToString() string {\n\treturn fmt.Sprintf(\"[ %d ]\", f.Data)\n}\n",
            "number": "1",
            "python": "class MinStack:\n    def __init__(self, top=None, min_frame=None):\n        self.top = top\n        self.min_frame = min_frame\n\n    def __repr__(self):\n        frames = []\n        top = self.top\n\n        while top:\n            frames.append(str(top))\n            top = top.next\n\n        # [] is falsy in Python\n        if frames:\n            return f'{\" -> \".join([\"top\"] + frames + [\"bottom\"])}; Min: {self.min_frame.data if self.min_frame else \"None\"}'\n\n        return 'empty stack'\n\n    def push(self, data):\n        frame = MinFrame(data, self.top)\n\n        # assumes that \"data\" is comparable to other \"data\" using standard operators\n        if self.min_frame:\n            if data < self.min_frame.data:\n                frame.previous_min_frame = self.min_frame\n                self.min_frame = frame\n        else:\n            self.min_frame = frame\n\n        self.top = frame\n\n    def pop(self):\n        if not self.top:\n            raise Exception('stack is empty')\n\n        if self.top is self.min_frame:\n            self.min_frame = self.top.previous_min_frame\n\n        frame = self.top\n        self.top = self.top.next\n\n        return frame.data\n\n    def min(self):\n        if not self.top:\n            raise Exception('stack is empty')\n\n        return self.min_frame.data\n\n\nclass MinFrame:\n    def __init__(self, data=None, next=None, previous_min_frame=None):\n        self.data = data\n        self.next = next\n        self.previous_min_frame = previous_min_frame\n\n    def __repr__(self):\n        return f'[ {self.data} ]'\n",
            "stem": "stacks_1",
            "title": "Stack Min",
            "ts": "class MinStack {\n  top: MinFrame\n  minFrame: MinFrame\n\n  constructor(top?: MinFrame, minFrame?: MinFrame) {\n    this.top = top\n    this.minFrame = minFrame\n  }\n\n  toString() {\n    const frames: string[] = []\n    let top = this.top\n\n    while (top) {\n      frames.push(top.toString())\n      top = top.next\n    }\n\n    if (frames.length > 0) {\n      const stackStrings = ['top', ...frames, 'bottom']\n      const min = this.minFrame ? this.minFrame.data : 'null'\n      return `${stackStrings.join(' -> ')}; Min: ${min}`\n    }\n\n    return 'empty stack'\n  }\n\n  push(data: number) {\n    const frame = new MinFrame(data, this.top)\n\n    if (this.minFrame) {\n      if (data < this.minFrame.data) {\n        frame.previousMinFrame = this.minFrame\n        this.minFrame = frame\n      }\n    } else {\n      this.minFrame = frame\n    }\n\n    this.top = frame\n  }\n\n  pop(): number {\n    if (!this.top) {\n      throw 'stack is empty'\n    }\n\n    if (this.top === this.minFrame) {\n      this.minFrame = this.top.previousMinFrame\n    }\n\n    const frame = this.top\n    this.top = this.top.next\n\n    return frame.data\n  }\n\n  min(): number {\n    if (!this.top) {\n      throw 'stack is empty'\n    }\n\n    return this.minFrame.data\n  }\n}\n\nclass MinFrame {\n  data: number\n  next: MinFrame\n  previousMinFrame: MinFrame\n\n  constructor(data?: number, next?: MinFrame, previousMinFrame?: MinFrame) {\n    this.data = data\n    this.next = next\n    this.previousMinFrame = previousMinFrame\n  }\n\n  toString() {\n    return `[ ${this.data} ]`\n  }\n}\n"
        },
        {
            "description": "Implement a data structure that maintains multiple stacks with a fixed capacity. When the stack overflows create a new stack to house the new entry. When a stack is consumed remove it from the structure. Also implement a popAt(i) method that removes the top item from the ith stack.",
            "go": "package stacks\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// StackSet is LIFO data structure\n// with multiple stacks\n// supporting O(1) push, pop, and popAt\ntype StackSet struct {\n\tStacks        []*Stack\n\tIndex         int\n\tStackCapacity int\n}\n\n// ToString provides a string representation for a stack set\nfunc (ss *StackSet) ToString() string {\n\tstacks := \"\"\n\n\tfor i, s := range ss.Stacks {\n\t\tstacks += fmt.Sprintf(\"%d: %s\\n\", i, s.ToString())\n\t}\n\n\treturn stacks\n}\n\n// Pop is O(1)\nfunc (ss *StackSet) Pop() int {\n\tif len(ss.Stacks) == 0 {\n\t\tpanic(\"stack set is empty\")\n\t}\n\n\tfor ss.Stacks[ss.Index].Top == nil {\n\t\tss.Stacks = ss.Stacks[:len(ss.Stacks)-1]\n\t\tss.Index--\n\n\t\tif ss.Index == -1 {\n\t\t\tss.Index = 0\n\t\t\tpanic(\"stack set is empty\")\n\t\t}\n\t}\n\n\treturn ss.Stacks[ss.Index].Pop()\n}\n\n// Push is O(1)\nfunc (ss *StackSet) Push(data int) {\n\tif len(ss.Stacks) == 0 {\n\t\tss.Stacks = append(ss.Stacks, &Stack{})\n\t\tss.Push(data)\n\t} else if ss.Stacks[ss.Index].Length == ss.StackCapacity {\n\t\tss.Index++\n\t\tss.Stacks = append(ss.Stacks, &Stack{})\n\t\tss.Push(data)\n\t} else {\n\t\tss.Stacks[ss.Index].Push(data)\n\t}\n}\n\n// PopAt is O(1)\n// this does not move frames between stacks\nfunc (ss *StackSet) PopAt(i int) int {\n\tif i >= len(ss.Stacks) {\n\t\tpanic(\"index out of bounds\")\n\t}\n\n\tif ss.Stacks[i].Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\treturn ss.Stacks[i].Pop()\n}\n\n// Stack is a LIFO data structure\ntype Stack struct {\n\tTop    *Frame\n\tLength int\n}\n\n// ToString provides a string representation for a stack\nfunc (s *Stack) ToString() string {\n\tframes := []string{}\n\ttop := s.Top\n\n\tfor top != nil {\n\t\tframes = append(frames, top.ToString())\n\t\ttop = top.Next\n\t}\n\n\tif len(frames) > 0 {\n\t\tss := []string{\"top\"}\n\t\tss = append(ss, frames...)\n\t\tss = append(ss, \"bottom\")\n\n\t\treturn strings.Join(ss, \" -> \")\n\t}\n\n\treturn \"empty stack\"\n}\n\n// Push O(1)\nfunc (s *Stack) Push(data int) {\n\tframe := &Frame{Data: data, Next: s.Top}\n\ts.Top = frame\n\ts.Length++\n}\n\n// Pop O(1)\nfunc (s *Stack) Pop() int {\n\tif s.Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\tframe := s.Top\n\ts.Top = s.Top.Next\n\ts.Length--\n\n\treturn frame.Data\n}\n\n// Frame is a single stack frame\ntype Frame struct {\n\tData int\n\tNext *Frame\n}\n\n// ToString provides a string representation for a stack frame\nfunc (f *Frame) ToString() string {\n\treturn fmt.Sprintf(\"[ %d ]\", f.Data)\n}\n",
            "number": "2",
            "python": "class StackSet:\n    def __init__(self, stack_capacity=None):\n        self.stacks = []\n        self.index = None\n        self.stack_capacity = stack_capacity\n\n    def __repr__(self):\n        stacks = \"\"\n\n        for i, s in enumerate(self.stacks):\n            stacks += f'{i}: {s}\\n'\n\n        return stacks\n\n    def pop(self):\n        if self.index == None:\n            raise Exception('stack set is empty')\n\n        # find a non-empty stack\n        # necessary to support popAt(i)\n        while not self.stacks[self.index].top:\n            # Python list built in pop\n            self.stacks.pop()\n            self.index -= 1\n\n            if self.index == -1:\n                self.index = None\n                raise Exception('stack set is empty')\n\n        return self.stacks[self.index].pop()\n\n    def push(self, data):\n        if self.index == None:\n            self.index = 0\n            self.stacks.append(Stack())\n            self.push(data)\n        elif self.stacks[self.index].length == self.stack_capacity:\n            self.index += 1\n            self.stacks.append(Stack())\n            self.push(data)\n        else:\n            self.stacks[self.index].push(data)\n\n    def popAt(self, i):\n        if i >= len(self.stacks):\n            raise IndexError\n\n        if not self.stacks[i].top:\n            raise Exception('stack is empty')\n\n        return self.stacks[i].pop()\n\n\nclass Stack:\n    def __init__(self, top=None):\n        self.top = top\n        self.length = 0\n\n    def __repr__(self):\n        frames = []\n        top = self.top\n\n        while top:\n            frames.append(str(top))\n            top = top.next\n\n        if frames:\n            return f'{\" -> \".join([\"top\"] + frames + [\"bottom\"])}'\n\n        return 'empty stack'\n\n    def push(self, data):\n        frame = Frame(data, self.top)\n        self.top = frame\n        self.length += 1\n\n    def pop(self):\n        if not self.top:\n            raise Exception('stack is empty')\n\n        frame = self.top\n        self.top = self.top.next\n        self.length -= 1\n\n        return frame.data\n\n\nclass Frame:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n\n    def __repr__(self):\n        return f'[ {self.data} ]'\n",
            "stem": "stacks_2",
            "title": "Stack Set",
            "ts": "class StackSet {\n  stacks: Stack[]\n  index: number\n  stackCapacity: number\n\n  constructor(stackCapacity: number) {\n    this.stacks = []\n    this.index = 0\n    this.stackCapacity = stackCapacity\n  }\n\n  toString(): string {\n    let stacks = ''\n\n    this.stacks.forEach((s, i) => {\n      stacks += `${i}: ${s.toString()}\\n`\n    })\n\n    return stacks\n  }\n\n  pop(): number {\n    if (this.stacks.length === 0) {\n      throw 'stack set is empty'\n    }\n\n    while (!this.stacks[this.index].top) {\n      this.stacks.pop()\n      this.index--\n\n      if (this.index === -1) {\n        this.index = 0\n        throw 'stack set is empty'\n      }\n    }\n\n    return this.stacks[this.index].pop()\n  }\n\n  push(data: number) {\n    if (this.stacks.length === 0) {\n      this.stacks.push(new Stack())\n      this.push(data)\n    } else if (this.stacks[this.index].length == this.stackCapacity) {\n      this.index++\n      this.stacks.push(new Stack())\n      this.push(data)\n    } else {\n      this.stacks[this.index].push(data)\n    }\n  }\n\n  popAt(i: number): number {\n    if (i >= this.stacks.length) {\n      throw 'index out of bounds'\n    }\n\n    if (!this.stacks[i].top) {\n      throw 'stack is empty'\n    }\n\n    return this.stacks[i].pop()\n  }\n}\n\nexport class Stack {\n  top: Frame\n  length: number\n\n  constructor() {\n    this.top = null\n    this.length = 0\n  }\n\n  toString(): string {\n    const frames: string[] = []\n    let top = this.top\n\n    while (top) {\n      frames.push(top.toString())\n      top = top.next\n    }\n\n    if (frames.length > 0) {\n      const stackStrings = ['top', ...frames, 'bottom']\n      return stackStrings.join(' -> ')\n    }\n\n    return 'empty stack'\n  }\n\n  push(data: number): void {\n    const frame = new Frame(data, this.top)\n    this.top = frame\n    this.length++\n  }\n\n  pop(): number {\n    if (!this.top) {\n      throw 'stack is empty'\n    }\n\n    const frame = this.top\n    this.top = this.top.next\n    this.length--\n\n    return frame.data\n  }\n}\n\nclass Frame {\n  data: number\n  next: Frame\n\n  constructor(data: number, next?: Frame) {\n    this.data = data\n    this.next = next\n  }\n\n  toString(): string {\n    return `[ ${this.data} ]`\n  }\n}\n"
        },
        {
            "description": "Implement a FIFO queue using two LIFO stacks.",
            "go": "package stacks\n\nimport \"fmt\"\n\n// for stack type definition see Stack Set\n\n// Queue is a FIFO data structure implemented using two stacks\ntype Queue struct {\n\tFront Stack\n\tBack  Stack\n}\n\n// ToString provides a string representation for a queue\nfunc (q *Queue) ToString() string {\n\treturn fmt.Sprintf(\"Front: %s\\nBack: %s\\n\", q.Front.ToString(), q.Back.ToString())\n}\n\n// O(n)\nfunc (q *Queue) transfer(source, destination *Stack) {\n\tfor source.Top != nil {\n\t\tdestination.Push(source.Pop())\n\t}\n}\n\n// Add is O(1) without a transfer and O(n) with a transfer\nfunc (q *Queue) Add(data int) {\n\tif q.Back.Top == nil {\n\t\tq.transfer(&q.Front, &q.Back)\n\t}\n\tq.Back.Push(data)\n}\n\n// Remove is O(1) without a transfer and O(n) with a transfer\nfunc (q *Queue) Remove() int {\n\tif q.Front.Top == nil {\n\t\tq.transfer(&q.Back, &q.Front)\n\t\tif q.Front.Top == nil {\n\t\t\tpanic(\"queue is empty\")\n\t\t}\n\t}\n\n\treturn q.Front.Pop()\n}\n",
            "number": "3",
            "python": "from stacks_2 import Stack\n\n# for stack class definition see Stack Set\n\n# reverse one stack into the other as necessary\n# pushing only onto the back stack\n# and popping only from the front stack\n\n\nclass Queue:\n    def __init__(self):\n        self.front = Stack()\n        self.back = Stack()\n\n    def __repr__(self):\n        return f'front: {self.front}\\nback: {self.back}'\n\n    def add(self, data):\n        if not self.back.top:\n            self.transfer(self.front, self.back)\n        self.back.push(data)\n\n    def remove(self):\n        if not self.front.top:\n            self.transfer(self.back, self.front)\n            if not self.front.top:\n                raise Exception('queue is empty')\n\n        return self.front.pop()\n\n    def transfer(self, source, destination):\n        while source.top:\n            destination.push(source.pop())\n",
            "stem": "stacks_3",
            "title": "Queue Via Stacks",
            "ts": "import { Stack } from './stacks_2'\n\nclass Queue {\n  front: Stack\n  back: Stack\n\n  constructor() {\n    this.front = new Stack()\n    this.back = new Stack()\n  }\n\n  toString(): string {\n    return `Front: ${this.front.toString()}\\nBack: ${this.back.toString()}`\n  }\n\n  private transfer(source: Stack, destination: Stack): void {\n    while (source.top) {\n      destination.push(source.pop())\n    }\n  }\n\n  add(data: number): void {\n    if (!this.back.top) {\n      this.transfer(this.front, this.back)\n    }\n    this.back.push(data)\n  }\n\n  remove(): number {\n    if (!this.front.top) {\n      this.transfer(this.back, this.front)\n\n      if (!this.front.top) {\n        throw 'queue is empty'\n      }\n    }\n\n    return this.front.pop()\n  }\n}\n"
        }
    ],
    "Strings": [
        {
            "description": "Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?",
            "go": "package iterables\n\n// IsUnique with access to O(1) lookup data structures O(n)\nfunc IsUnique(s string) bool {\n\tm := map[rune]bool{}\n\tfor _, c := range s {\n\t\tif m[c] {\n\t\t\treturn false\n\t\t}\n\t\tm[c] = true\n\t}\n\treturn true\n}\n\n// IsUniqueSlow without access to any additional data structures O(n^2)\n// could sort in O(n log(n)), but the assumption is that a new string\n// constitutes an additional data structure\nfunc IsUniqueSlow(s string) bool {\n\tfor i, c := range s {\n\t\tfor j := i + 1; j < len(s); j++ {\n\t\t\tif c == rune(s[j]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n",
            "number": "1",
            "python": "# with access to O(1) lookup data structures O(n)\ndef is_unique(s):\n    char_set = set()\n    for c in s:\n        if c in char_set:\n            return False\n        char_set.add(c)\n    return True\n\n\n# without access to any additional data structures O(n^2)\n# could sort in O(n log(n)), but the assumption is that a new string\n# constitutes an additional data structure\ndef is_unique_slow(s):\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                return False\n    return True\n",
            "stem": "strings_1",
            "title": "Is Unique",
            "ts": "// with access to O(1) lookup data structures O(n)\nfunction isUnique(s: string): boolean {\n  const charSet: Set<string> = new Set()\n  for (const c of s) {\n    if (charSet.has(c)) {\n      return false\n    }\n    charSet.add(c)\n  }\n  return true\n}\n\n// without access to any additional data structures O(n^2)\n// could sort in O(n log(n)), but the assumption is that a new string\n// constitutes an additional data structure\nfunction isUniqueSlow(s: string): boolean {\n  let i = 0\n  for (const c of s) {\n    for (let j = i + 1; j < s.length; j++) {\n      if (c === s[j]) {\n        return false\n      }\n    }\n    i++\n  }\n  return true\n}\n"
        },
        {
            "description": "Given two strings, write a method to decide if one is a permutation of the other.",
            "go": "package iterables\n\n// CheckPermutation runs in O(n + m)\nfunc CheckPermutation(s1, s2 string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\n\tcharCount := map[rune]int{}\n\n\tfor _, c := range s1 {\n\t\tif _, ok := charCount[c]; ok {\n\t\t\tcharCount[c]++\n\t\t} else {\n\t\t\tcharCount[c] = 1\n\t\t}\n\t}\n\n\tfor _, c := range s2 {\n\t\tif n, ok := charCount[c]; !ok || n == 0 {\n\t\t\treturn false\n\t\t}\n\t\tcharCount[c]--\n\t}\n\n\treturn true\n}\n",
            "number": "2",
            "python": "# O(n + m)\ndef check_permutation(s1, s2):\n    # need to be of equal length O(1)\n    if len(s1) != len(s2):\n        return False\n\n    # for O(1) lookup\n    char_count = {}\n\n    # O(n) where n is the length of s1\n    for c in s1:\n        if char_count.get(c):\n            char_count[c] += 1\n        else:\n            char_count[c] = 1\n\n    # O(m) where m is the length of s2\n    for c in s2:\n        # relies on 0 being falsy\n        if not char_count.get(c):\n            return False\n        char_count[c] -= 1\n\n    return True\n",
            "stem": "strings_2",
            "title": "Check Permutation",
            "ts": "// O(n + m)\nfunction checkPermutation(s1: string, s2: string): boolean {\n  if (s1.length !== s2.length) {\n    return false\n  }\n\n  const charCount: { [key: string]: number } = {}\n\n  for (const c of s1) {\n    if (charCount[c]) {\n      charCount[c]++\n    } else {\n      charCount[c] = 1\n    }\n  }\n\n  for (const c of s2) {\n    if (!charCount[c]) {\n      return false\n    }\n    charCount[c]--\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Write a method to replace all spaces in a string with '%20'.",
            "go": "package iterables\n\nimport \"strings\"\n\n// URLEncode replaces all spaces with %20\n//could rely on built in replace method, but that seems to be what the problem is asking us to implement\nfunc URLEncode(s string) string {\n\t// amortized cost to append to a slice in Go is O(1) even if O(n) in the worst case\n\tss := []string{}\n\n\t// O(n) where n is the length of the string\n\tfor _, c := range s {\n\t\tif c == ' ' {\n\t\t\tss = append(ss, \"%20\")\n\t\t} else {\n\t\t\t// complexity to cast is O(m) where m is the number of bytes\n\t\t\t// for each rune comprising the string this is effectively O(1)\n\t\t\tss = append(ss, string(c))\n\t\t}\n\t}\n\n\t// strings.Join is O(n)\n\treturn strings.Join(ss, \"\")\n}\n",
            "number": "3",
            "python": "# O(n)\n# could rely on built in replace method, but that seems to be what the problem is asking us to implement\ndef url_encode(s):\n    # strings are immutable so building a list and using ''.join()\n    # is a better approach than building a new string with +=\n\n    # O(n) for the list comprehension and O(n) for join()\n    return ''.join(['%20' if c == ' ' else c for c in s])\n",
            "stem": "strings_3",
            "title": "URL Encode",
            "ts": "// O(n)\n// could rely on built in replace method, but that seems to be what the problem is asking us to implement\nfunction URLEncode(s: string): string {\n  const charArray: string[] = []\n  for (const c of s) {\n    if (c === ' ') {\n      charArray.push('%20')\n    } else {\n      charArray.push(c)\n    }\n  }\n  return charArray.join('')\n}\n"
        },
        {
            "description": "Given a string, write a method to check if it is a permutation of a palindrome.",
            "go": "package iterables\n\n// PalindromePermutation runs in O(n)\nfunc PalindromePermutation(s string) bool {\n\tm := map[rune]int{}\n\n\tfor _, c := range s {\n\t\t// in Go, there is an implied zero value based on type\n\t\t// therefore, you don't need the existence check common in\n\t\t// in other languages before incrementing the count\n\t\tm[c]++\n\t}\n\n\thasOdd := false\n\n\tfor k := range m {\n\t\tif m[k]%2 == 1 {\n\t\t\tif hasOdd {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\thasOdd = true\n\t\t}\n\t}\n\n\treturn true\n}\n",
            "number": "4",
            "python": "# O(n)\ndef palindrome_permutation(s):\n    character_count = {}\n\n    # O(n)\n    for c in s:\n        if character_count.get(c):\n            character_count[c] += 1\n        else:\n            character_count[c] = 1\n\n    # a string is a palindrome if all character counts are even\n    # if any are odd counts, there can be only one serving as the middle character\n\n    has_odd = False\n\n    # number of unique characters is always <= number of characters still O(n)\n    for v in character_count.values():\n        if v % 2 == 1:\n            if has_odd:\n                # more than one odd\n                return False\n            has_odd = True\n\n    return True\n",
            "stem": "strings_4",
            "title": "Palindrome Permutation",
            "ts": "// O(n)\nfunction palindromePermutation(s: string): boolean {\n  const charCount: { [key: string]: number } = {}\n  for (const c of s) {\n    if (charCount[c]) {\n      charCount[c]++\n    } else {\n      charCount[c] = 1\n    }\n  }\n\n  let hasOdd = false\n\n  // Object.values requires a later TS transpilation target than ES6\n  for (const char in charCount) {\n    if (charCount[char] % 2 === 1) {\n      if (hasOdd) {\n        return false\n      }\n      hasOdd = true\n    }\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Write a method to determine if two strings are one edit removed from each other. An edit constitutes replacing, removing or adding a single character.",
            "go": "package iterables\n\n// O(n)\nfunc hasAdditionalCharacter(s1, s2 string) bool {\n\thasSkipped := false\n\ti := 0\n\tj := 0\n\n\tfor i < len(s1) {\n\t\tif s1[i] == s2[j] {\n\t\t\ti++\n\t\t\tj++\n\t\t} else if !hasSkipped {\n\t\t\thasSkipped = true\n\t\t\tj++\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// OneAway runs in O(n)\nfunc OneAway(s1, s2 string) bool {\n\tif len(s2)-len(s1) == 1 {\n\t\treturn hasAdditionalCharacter(s1, s2)\n\t} else if len(s1)-len(s2) == 1 {\n\t\treturn hasAdditionalCharacter(s2, s1)\n\t} else if len(s1) == len(s2) {\n\t\tseenReplacement := false\n\t\tfor i, c := range s1 {\n\t\t\tif c != rune(s2[i]) {\n\t\t\t\tif seenReplacement {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tseenReplacement = true\n\t\t\t}\n\t\t}\n\t\treturn seenReplacement\n\t}\n\treturn false\n}\n",
            "number": "5",
            "python": "# O(n) determines if s2 is s1 with an additional character\ndef has_additional_character(s1, s2):\n    # can skip a single additional character in s2 to create s1\n    has_skipped = False\n    i = 0\n    j = 0\n\n    while i < len(s1):\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        elif not has_skipped:\n            has_skipped = True\n            j += 1\n        else:\n            return False\n\n    return True\n\n\n# O(n)\ndef one_away(s1, s2):\n    # O(n) add case\n    if len(s2) - len(s1) == 1:\n        return has_additional_character(s1, s2)\n\n    # O(n) remove case\n    elif len(s1) - len(s2) == 1:\n        return has_additional_character(s2, s1)\n\n    # O(n) handle replace\n    elif len(s1) == len(s2):\n        # can have at most one replacement\n        seen_replacement = False\n\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                if seen_replacement:\n                    return False\n                seen_replacement = True\n\n        # will be False if strings are identical\n        return seen_replacement\n\n    # if string lengths differ by more than 1\n    return False\n",
            "stem": "strings_5",
            "title": "One Away",
            "ts": "// O(n)\nfunction hasAdditionalCharacter(s1: string, s2: string): boolean {\n  let hasSkipped = false\n  let i = 0\n  let j = 0\n\n  while (i < s1.length) {\n    if (s1[i] == s2[j]) {\n      i++\n      j++\n    } else if (!hasSkipped) {\n      hasSkipped = true\n      j++\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\n// O(n)\nfunction oneAway(s1: string, s2: string): boolean {\n  if (s2.length - s1.length === 1) {\n    return hasAdditionalCharacter(s1, s2)\n  } else if (s1.length - s2.length === 1) {\n    return hasAdditionalCharacter(s2, s1)\n  } else if (s1.length === s2.length) {\n    let seenReplacement = false\n    for (let i = 0; i < s1.length; i++) {\n      if (s1[i] !== s2[i]) {\n        if (seenReplacement) {\n          return false\n        }\n        seenReplacement = true\n      }\n    }\n    return seenReplacement\n  }\n  return false\n}\n"
        },
        {
            "description": "Implement a method to perform basic string compression using the counts of repeated characters. For example, \"aabcccccaaa\" => \"s2b1c5a3\". If the compressed string would not be smaller, your method should return the original string. Assume the string fits the pattern [a-zA-Z]*.",
            "go": "package iterables\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CompressString runs in O(n)\nfunc CompressString(s string) string {\n\t// handle empty string\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\n\tss := []string{}\n\tstartIndex := 0\n\tcurrentIndex := 0\n\tcurrentChar := rune(s[0])\n\n\t// O(n)\n\tfor _, c := range s {\n\t\tif c != currentChar {\n\t\t\tss = append(ss, []string{string(currentChar), strconv.Itoa(currentIndex - startIndex)}...)\n\t\t\tstartIndex = currentIndex\n\t\t\tcurrentChar = c\n\t\t}\n\t\tcurrentIndex++\n\t}\n\n\t// handle the final character sequence\n\tss = append(ss, []string{string(currentChar), strconv.Itoa(currentIndex - startIndex)}...)\n\n\tif len(ss) < len(s) {\n\t\t// O(n)\n\t\treturn strings.Join(ss, \"\")\n\t}\n\n\treturn s\n}\n",
            "number": "6",
            "python": "# O(n)\ndef compress_string(s):\n    # handle edge case ahead of assignment to s[0]\n    if s == '':\n        return ''\n\n    # accumulator list to store compressed string\n    acc = []\n\n    start_index = 0\n    current_index = 0\n    current_char = s[0]\n\n    # O(n)\n    for c in s:\n        if c != current_char:\n            # O(1)\n            acc.extend([current_char, str(current_index - start_index)])\n            start_index = current_index\n            current_char = c\n        current_index += 1\n\n    acc.extend([current_char, str(current_index - start_index)])\n\n    # O(n)\n    return ''.join(acc) if len(acc) < len(s) else s\n",
            "stem": "strings_6",
            "title": "String Compression",
            "ts": "// O(n)\nfunction compressString(s: string): string {\n  if (s === '') {\n    return ''\n  }\n\n  const acc: string[] = []\n  let startIndex = 0\n  let currentIndex = 0\n  let currentChar = s[0]\n\n  for (const c of s) {\n    if (c !== currentChar) {\n      acc.push(currentChar, '' + (currentIndex - startIndex))\n      startIndex = currentIndex\n      currentChar = c\n    }\n    currentIndex++\n  }\n\n  acc.push(currentChar, '' + (currentIndex - startIndex))\n\n  return acc.length > s.length ? s : acc.join('')\n}\n"
        },
        {
            "description": "Using the built in language specific string method for isSubstring and given two strings, s1 and s2, check if s2 is a rotation of s1 using only a single call to isSubstring. (e.g. \"arfoob\" is a rotation of \"foobar\")",
            "go": "package iterables\n\nimport \"strings\"\n\n// IsRotation runs in O(n)\nfunc IsRotation(s1, s2 string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\n\treturn strings.Contains(s2+s2, s1)\n}\n",
            "number": "7",
            "python": "# O(n)\ndef is_rotation(s1, s2):\n    if len(s1) != len(s2):\n        return False\n\n    # let AB represent s1\n    # where A is the first part of the string and B is the second\n    # s2 is a rotation <=> s2 == BA (necessary and sufficient)\n    # let s2 concatenated be represented by BABA\n    # if s1 can be represented by AB then it must be a substring of s2 + s2\n\n    # O(n)\n    return s1 in s2 + s2\n",
            "stem": "strings_7",
            "title": "String Rotation",
            "ts": "// O(n)\nfunction isRotation(s1: string, s2: string): boolean {\n  if (s1.length !== s2.length) {\n    return false\n  }\n\n  return (s2 + s2).includes(s1)\n}\n"
        }
    ],
    "Trees": [
        {
            "description": "Given a sorted array of unique integers, write a method to generate a minimal height binary search tree.",
            "go": "package trees\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n// TreeNode represents a binary tree node\ntype TreeNode struct {\n\tData  int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\n// ToString provides a string representation for binary tree node\nfunc (n *TreeNode) ToString() string {\n\tif n == nil {\n\t\treturn \"nil\"\n\t}\n\tif n.Left == nil && n.Right == nil {\n\t\treturn strconv.Itoa(n.Data)\n\t}\n\treturn fmt.Sprintf(\"%d => (%s, %s)\", n.Data, n.Left.ToString(), n.Right.ToString())\n}\n\n// O(1)\nfunc splitSlice(ns []int) (middle int, left []int, right []int) {\n\ti := len(ns) / 2\n\treturn ns[i], ns[:i], ns[i+1:]\n}\n\n// MinBST runs in O(n)\nfunc MinBST(ns []int, node *TreeNode) *TreeNode {\n\tif len(ns) == 0 {\n\t\treturn nil\n\t}\n\n\tif node == nil {\n\t\tnode = new(TreeNode)\n\t}\n\n\tdata, left, right := splitSlice(ns)\n\tnode.Data = data\n\n\tif len(left) > 0 {\n\t\tnode.Left = new(TreeNode)\n\t\tMinBST(left, node.Left)\n\t}\n\n\tif len(right) > 0 {\n\t\tnode.Right = new(TreeNode)\n\t\tMinBST(right, node.Right)\n\t}\n\n\treturn node\n}\n",
            "number": "1",
            "python": "class TreeNode:\n    def __init__(self, data=None, left=None, right=None):\n        self.data = data\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        if not self.left and not self.right:\n            return str(self.data)\n        return f'{self.data} => ({self.left}, {self.right})'\n\n\n# O(1) return the middle of the list and a reference\n# to left and right sublists not including the middle item\ndef splice_middle(l):\n    i = len(l) // 2\n    return l[i], l[:i], l[i+1:]\n\n\n# O(n) one recursive call per item in the list\ndef min_bst(l, node=TreeNode()):\n    if len(l) == 0:\n        return\n\n    data, left, right = splice_middle(l)\n    node.data = data\n\n    if len(left):\n        node.left = TreeNode()\n        min_bst(left, node.left)\n    if len(right):\n        node.right = TreeNode()\n        min_bst(right, node.right)\n\n    return node\n",
            "stem": "trees_1",
            "title": "Minimal BST",
            "ts": "export class TreeNode {\n  data: number\n  left: TreeNode\n  right: TreeNode\n\n  constructor(data?: number, left?: TreeNode, right?: TreeNode) {\n    this.data = data\n    this.left = left\n    this.right = right\n  }\n\n  toString(): string {\n    if (!this.left && !this.right) return '' + this.data\n    else if (!this.left) return `${this.data} (null, ${this.right.toString()})`\n    else if (!this.right) return `${this.data} (${this.left.toString()}, null)`\n    return `${this.data} (${this.left.toString()}, ${this.right.toString()})`\n  }\n}\n\ninterface SplitList {\n  middle: number\n  left: number[]\n  right: number[]\n}\n\n// O(1)\nfunction splitList(ns: number[]): SplitList {\n  const i = Math.floor(ns.length / 2)\n  return {\n    middle: ns[i],\n    left: ns.slice(0, i),\n    right: ns.slice(i + 1),\n  }\n}\n\n// O(n)\nfunction minBST(ns: number[], node?: TreeNode) {\n  if (!node) {\n    node = new TreeNode()\n  }\n\n  const { middle, left, right } = splitList(ns)\n  node.data = middle\n\n  if (left.length) {\n    node.left = new TreeNode()\n    minBST(left, node.left)\n  }\n\n  if (right.length) {\n    node.right = new TreeNode()\n    minBST(right, node.right)\n  }\n\n  return node\n}\n"
        },
        {
            "description": "Given a binary tree, write a method which creates d-many linked lists, one for each depth of the tree linking the nodes at that depth from left to right.",
            "go": "package trees\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// for TreeNode type def see Minimal BST\n\n// QueueNode stores a tree node, its depth, and a pointer to the next node\ntype QueueNode struct {\n\tTreeNode *TreeNode\n\tDepth    int\n\tNext     *QueueNode\n}\n\n// ToString QueueNode => string\nfunc (n *QueueNode) ToString() string {\n\treturn fmt.Sprintf(\"(%d, %d)\", n.TreeNode.Data, n.Depth)\n}\n\n// Queue is a FIFO data structure\ntype Queue struct {\n\tHead   *QueueNode\n\tTail   *QueueNode\n\tLength int\n}\n\n// ToString Queue => string\nfunc (q *Queue) ToString() string {\n\tss := []string{}\n\tnode := q.Head\n\n\tfor node != nil {\n\t\tss = append(ss, node.ToString())\n\t\tnode = node.Next\n\t}\n\n\treturn strings.Join(ss, \" -> \")\n}\n\n// Add a new node in O(1)\nfunc (q *Queue) Add(treeNode *TreeNode, depth int) {\n\tqueueNode := new(QueueNode)\n\tqueueNode.TreeNode = treeNode\n\tqueueNode.Depth = depth\n\n\tif q.Head == nil {\n\t\tq.Head = queueNode\n\t}\n\n\tif q.Tail != nil {\n\t\tq.Tail.Next = queueNode\n\t}\n\n\tq.Tail = queueNode\n\tq.Length++\n}\n\n// Remove a node and return the tree node and depth in O(1)\nfunc (q *Queue) Remove() (*TreeNode, int) {\n\tif q.Head == nil {\n\t\tpanic(\"queue is empty\")\n\t}\n\n\tnode := q.Head\n\tq.Head = q.Head.Next\n\n\tif q.Length == 1 {\n\t\tq.Tail = nil\n\t}\n\n\tq.Length--\n\n\treturn node.TreeNode, node.Depth\n}\n\n// ListDepths builds a slice of queues in O(n)\nfunc ListDepths(treeNode *TreeNode, depth int, q *Queue, depths []*Queue) []*Queue {\n\t// add an additional queue for each depth encountered\n\tif depth == len(depths) {\n\t\tdepths = append(depths, new(Queue))\n\t}\n\n\t// add node to queue on depths slice\n\tdepths[depth].Add(treeNode, depth)\n\n\tif treeNode.Left != nil {\n\t\tq.Add(treeNode.Left, depth+1)\n\t}\n\n\tif treeNode.Right != nil {\n\t\tq.Add(treeNode.Right, depth+1)\n\t}\n\n\tif q.Length == 0 {\n\t\treturn depths\n\t}\n\n\ttreeNode, depth = q.Remove()\n\n\treturn ListDepths(treeNode, depth, q, depths)\n}\n",
            "number": "2",
            "python": "from trees_1 import TreeNode\n\n# for tree node class definition see Minimal BST\n\n\nclass QueueNode:\n    def __init__(self, tree_node=None, depth=None, next=None):\n        self.tree_node = tree_node\n        self.depth = depth\n        self.next = next\n\n    def __repr__(self):\n        return str((self.tree_node.data, self.depth))\n\n\n# implemented for O(1) removal of the first element\nclass Queue:\n    def __init__(self):\n        self.tail = None\n        self.head = None\n        self.length = 0\n\n    def __repr__(self):\n        nodes = []\n        node = self.head\n\n        while node:\n            nodes.append(str(node))\n            node = node.next\n\n        return ' -> '.join(nodes)\n\n    def add(self, tree_node, depth):\n        node = QueueNode(tree_node, depth)\n\n        if not self.head:\n            self.head = node\n\n        if self.tail:\n            self.tail.next = node\n\n        self.tail = node\n        self.length += 1\n\n    def remove(self):\n        if not self.head:\n            raise Exception('queue is empty')\n\n        node = self.head\n        self.head = self.head.next\n\n        if self.length == 1:\n            self.tail = None\n\n        self.length -= 1\n\n        return node.tree_node, node.depth\n\n\n# O(n)\n# node_depth is a tuple containing the binary tree node and the depth it was found\n# queue is used to implement BFS storing (node, depth) tuples for FIFO access\n# depths is a list of queues containing all node data at depth d\n# d is both the index of the depths list and the depth in the tree\ndef list_depths(tree_node, depth, queue=Queue(), depths=[]):\n    if depth == len(depths):\n        depths.append(Queue())\n\n    depths[depth].add(tree_node, depth)\n\n    if tree_node.left:\n        queue.add(tree_node.left, depth + 1)\n    if tree_node.right:\n        queue.add(tree_node.right, depth + 1)\n\n    if queue.length == 0:\n        return depths\n\n    tree_node, depth = queue.remove()\n    return list_depths(tree_node, depth, queue, depths)\n",
            "stem": "trees_2",
            "title": "Depth Lists",
            "ts": "import { TreeNode } from './trees_1'\n\n// for TreeNode class see Minimal BST\n\nclass QueueNode {\n  treeNode: TreeNode\n  depth: number\n  next: QueueNode\n\n  constructor(treeNode?: TreeNode, depth?: number, next?: QueueNode) {\n    this.treeNode = treeNode\n    this.depth = depth\n    this.next = next\n  }\n\n  toString(): string {\n    return `(${this.treeNode.data}, ${this.depth})`\n  }\n}\n\nclass Queue {\n  head: QueueNode\n  tail: QueueNode\n  length: number\n\n  constructor(head?: QueueNode, tail?: QueueNode) {\n    this.head = head\n    this.tail = tail\n    this.length = 0\n  }\n\n  toString(): string {\n    const ss: string[] = []\n    let node = this.head\n\n    while (node) {\n      ss.push(node.toString())\n      node = node.next\n    }\n\n    return ss.join(' -> ')\n  }\n\n  add(treeNode: TreeNode, depth: number): void {\n    const node = new QueueNode(treeNode, depth)\n\n    if (!this.head) {\n      this.head = node\n    }\n\n    if (this.tail) {\n      this.tail.next = node\n    }\n\n    this.tail = node\n    this.length++\n  }\n\n  remove(): QueueNode {\n    if (!this.head) {\n      throw 'queue is empty'\n    }\n\n    const node = this.head\n    this.head = this.head.next\n\n    if (this.length === 1) {\n      this.tail = null\n    }\n\n    this.length--\n\n    return node\n  }\n}\n\n// O(n)\nfunction listDepths(\n  treeNode: TreeNode,\n  depth = 0,\n  queue: Queue = new Queue(),\n  depths: Queue[] = [],\n): Queue[] {\n  if (depth == depths.length) {\n    depths.push(new Queue())\n  }\n\n  depths[depth].add(treeNode, depth)\n\n  if (treeNode.left) {\n    queue.add(treeNode.left, depth + 1)\n  }\n  if (treeNode.right) {\n    queue.add(treeNode.right, depth + 1)\n  }\n\n  if (queue.length == 0) {\n    return depths\n  }\n\n  const { treeNode: nextNode, depth: nextDepth } = queue.remove()\n  return listDepths(nextNode, nextDepth, queue, depths)\n}\n"
        },
        {
            "description": "Write a method to determine if a binary tree is balanced, where balanced means that the heights of each subtree of any node do not differ by more than one.",
            "go": "package trees\n\nimport (\n\t\"math\"\n\t\"sync\"\n)\n\n// for TreeNode type def see Minimal BST\n\n// this implementation builds on the Python solution\n// to exhibit some of what makes Go a wonderful tool\n// for dealing with concurrency\n\n// NodeState represents the state of a node in the tree\n// with respect to the properties we care about:\n// height and balance of the two subtrees\n// height can only be an int, but Go's math module requires float64\n// for Max() and Abs()\ntype NodeState struct {\n\tIsBalanced bool\n\tHeight     float64\n}\n\n// IsBalanced runs in O(n)\nfunc IsBalanced(tn *TreeNode, wgs chan *sync.WaitGroup, wg *sync.WaitGroup, result *NodeState) {\n\t// defer an anonymous function so that Done()\n\t// is called regardless of how this function exits\n\t// without defer this code would need to appear above every return statement\n\t// hooray Go!\n\tdefer func() {\n\t\tif wg != nil {\n\t\t\twg.Done()\n\t\t}\n\t}()\n\n\t// base case: nil node\n\t// by convention a single node has height 0, hence -1 for a nil\n\t// set NodeState and return\n\tif tn == nil {\n\t\tresult.IsBalanced = true\n\t\tresult.Height = -1\n\t\treturn\n\t}\n\n\t// allocate two new NodeStates\n\tleft := new(NodeState)\n\tright := new(NodeState)\n\n\t// select is one my favorite Go concepts\n\t// if a WaitGroup is available this thread is free to divide\n\t// otherwise proceed synchronously\n\tselect {\n\tcase wgNext := <-wgs:\n\t\t// set up a stop condition until wgNext.Done() is called 2 times\n\t\twgNext.Add(2)\n\n\t\t// launch two new threads in parallel to check the right and left subtrees\n\t\tgo IsBalanced(tn.Left, wgs, wgNext, left)\n\t\tgo IsBalanced(tn.Right, wgs, wgNext, right)\n\n\t\t// wait for Done() to be called 2 times\n\t\twgNext.Wait()\n\n\t\t// put this WaitGroup back on the channel for another thread to use\n\t\twgs <- wgNext\n\tdefault:\n\t\t// no bandwidth left to split, proceed without concurrency\n\t\tIsBalanced(tn.Left, wgs, nil, left)\n\n\t\t// since this is sequential we can save a call on the right subtree\n\t\t// if the left comes back false\n\t\tif !left.IsBalanced {\n\t\t\tresult.IsBalanced = false\n\t\t\treturn\n\t\t}\n\n\t\tIsBalanced(tn.Right, wgs, nil, right)\n\t}\n\n\t// check the imbalance condition at this node\n\t// now that we know the heights of the subtrees\n\tif math.Abs(left.Height-right.Height) > 1 {\n\t\tresult.IsBalanced = false\n\t\treturn\n\t}\n\n\t// carry the IsBalanced state of all decendants up to the root\n\tresult.IsBalanced = left.IsBalanced && right.IsBalanced\n\n\t// height is the maximum height of the left and right subtree plus this node\n\tresult.Height = 1 + math.Max(left.Height, right.Height)\n}\n\n// IsBalancedWrapper simply returns the boolean portion of the struct in O(n)\n// this function also sets up the concurrency infrastructure\nfunc IsBalancedWrapper(tn *TreeNode) bool {\n\t// there can exist up to maxSplits * 2 threads\n\t// since a single waitGroup is being used to support two parallel recursive calls\n\tconst maxSplits = 4\n\twgs := make(chan *sync.WaitGroup, maxSplits)\n\n\tfor i := 0; i < maxSplits; i++ {\n\t\twgs <- new(sync.WaitGroup)\n\t}\n\n\tresult := new(NodeState)\n\tIsBalanced(tn, wgs, nil, result)\n\n\treturn result.IsBalanced\n}\n",
            "number": "3",
            "python": "from trees_1 import TreeNode\n\n# for tree node class definition see Minimal BST\n\n\n# O(n)\n# figures out the height of the tree\n# while looking for imbalance at every node\ndef is_balanced(node):\n    if not node:\n        return (True, -1)\n\n    left_height = is_balanced(node.left)\n\n    if not left_height[0]:\n        return left_height\n\n    right_height = is_balanced(node.right)\n\n    if not right_height[0]:\n        return right_height\n\n    if abs(left_height[1] - right_height[1]) > 1:\n        # the number part of the tuple no longer matters\n        return (False, 0)\n\n    return (True, 1 + max(left_height[1], right_height[1]))\n\n\n# O(n)\ndef is_balanced_wrapper(node):\n    return is_balanced(node)[0]\n",
            "stem": "trees_3",
            "title": "Is Balanced",
            "ts": "import { TreeNode } from './trees_1'\n\n// for TreeNode class see Minimal BST\n\ninterface NodeState {\n  isBalanced: boolean\n  height: number\n}\n\n// O(n)\nfunction isBalanced(tn: TreeNode): NodeState {\n  if (!tn) {\n    return { isBalanced: true, height: -1 }\n  }\n\n  const left = isBalanced(tn.left)\n  if (!left.isBalanced) return left\n\n  const right = isBalanced(tn.right)\n  if (!right.isBalanced) return right\n\n  if (Math.abs(left.height - right.height) > 1) {\n    return { isBalanced: false, height: 0 }\n  }\n\n  return {\n    isBalanced: true,\n    height: 1 + Math.max(left.height, right.height),\n  }\n}\n\nfunction isBalancedWrapper(tn: TreeNode): boolean {\n  return isBalanced(tn).isBalanced\n}\n"
        },
        {
            "description": "Write a method to validate that a binary tree is a binary search tree.",
            "go": "package trees\n\n// for TreeNode type def see Minimal BST\n\n// IsBST runs in O(n)\n// using pointers for the bounds to leverage\n// a nil zero value rather than 0 which\n// is valid data for a TreeNode<int>\nfunc IsBST(tn *TreeNode, leftBound, rightBound *int) bool {\n\tif tn == nil {\n\t\treturn true\n\t}\n\n\tif leftBound != nil && tn.Data <= *leftBound {\n\t\treturn false\n\t}\n\n\tif rightBound != nil && tn.Data <= *rightBound {\n\t\treturn false\n\t}\n\n\treturn IsBST(tn.Left, leftBound, &tn.Data) && IsBST(tn.Right, &tn.Data, rightBound)\n}\n",
            "number": "4",
            "python": "from trees_1 import TreeNode\n\n# for tree node class definition see Minimal BST\n\n# base case\n# None => True\n\n# recursive case\n# node.data must fall within [left bound, right bound)\n# left and right bounds are defined by the min / max ancestors\n# left and right subtrees must satisfy isBST()\n\n\n# O(n)\ndef isBST(tn, left_bound=None, right_bound=None):\n    if not tn:\n        return True\n\n    # must be strictly greater than any ancestor to the left\n    if left_bound is not None and tn.data <= left_bound:\n        return False\n\n    # must be less than or equal to any ancestor to the right\n    if right_bound is not None and tn.data > right_bound:\n        return False\n\n    return isBST(tn.left, left_bound, tn.data) and isBST(tn.right, tn.data, right_bound)\n",
            "stem": "trees_4",
            "title": "Is BST",
            "ts": "import { TreeNode } from './trees_1'\n\n// for TreeNode class see Minimal BST\n\n// O(n)\nfunction isBST(\n  tn: TreeNode,\n  leftBound: number = null,\n  rightBound: number = null,\n): boolean {\n  if (!tn) return true\n\n  if (leftBound !== null && tn.data <= leftBound) {\n    return false\n  }\n\n  if (rightBound !== null && tn.data > rightBound) {\n    return false\n  }\n\n  return (\n    isBST(tn.left, leftBound, tn.data) && isBST(tn.right, tn.data, rightBound)\n  )\n}\n"
        },
        {
            "description": "Given reference to a node in a BST write a method to return the next node in an in-order traversal assuming each node maintains a reference to its parent.",
            "go": "package trees\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n// TreeNodeWithParent represents a binary tree node with a reference to its parent node\ntype TreeNodeWithParent struct {\n\tData   int\n\tParent *TreeNodeWithParent\n\tLeft   *TreeNodeWithParent\n\tRight  *TreeNodeWithParent\n}\n\n// ToString provides a string representation for binary tree node\nfunc (n *TreeNodeWithParent) ToString() string {\n\tif n == nil {\n\t\treturn \"nil\"\n\t}\n\tif n.Left == nil && n.Right == nil {\n\t\treturn strconv.Itoa(n.Data)\n\t}\n\treturn fmt.Sprintf(\"%d => (%s, %s)\", n.Data, n.Left.ToString(), n.Right.ToString())\n}\n\n// checkRight runs in O(log n)\nfunc checkRight(tn *TreeNodeWithParent) *TreeNodeWithParent {\n\tfor tn.Left != nil {\n\t\ttn = tn.Left\n\t}\n\n\treturn tn\n}\n\n// checkParent runs in O(log n)\nfunc checkParent(tn *TreeNodeWithParent) *TreeNodeWithParent {\n\tparent := tn.Parent\n\n\tfor parent != nil {\n\t\tif parent.Data >= tn.Data {\n\t\t\treturn parent\n\t\t}\n\t\tparent = parent.Parent\n\t}\n\n\treturn nil\n}\n\n// FindNext runs in O(log n)\nfunc FindNext(tn *TreeNodeWithParent) *TreeNodeWithParent {\n\tif tn == nil {\n\t\treturn nil\n\t}\n\n\tif tn.Right != nil {\n\t\treturn checkRight(tn.Right)\n\t}\n\n\treturn checkParent(tn)\n}",
            "number": "5",
            "python": "class TreeNodeWithParent:\n    def __init__(self, data=None, parent=None, left=None, right=None):\n        self.data = data\n        self.parent = parent\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        if not self.left and not self.right:\n            return str(self.data)\n        return f'{self.data} => ({self.left}, {self.right})'\n\n\n# O(log n)\n# return the left most node of this subtree\ndef check_right(tn):\n    while tn.left:\n        tn = tn.left\n\n    return tn\n\n\n# O(log n)\n# return the first ancestor whose value is greater than\n# or equal to the value of the source node\ndef check_parent(tn):\n    parent = tn.parent\n\n    while parent:\n        if parent.data >= tn.data:\n            return parent\n        parent = parent.parent\n\n    return None\n\n\ndef find_next(tn):\n    if not tn:\n        return None\n\n    if tn.right:\n        return check_right(tn.right)\n\n    return check_parent(tn)\n",
            "stem": "trees_5",
            "title": "Successor",
            "ts": "export class TreeNodeWithParent {\n  data: number\n  parent: TreeNodeWithParent\n  left: TreeNodeWithParent\n  right: TreeNodeWithParent\n\n  constructor(\n    data?: number,\n    parent?: TreeNodeWithParent,\n    left?: TreeNodeWithParent,\n    right?: TreeNodeWithParent,\n  ) {\n    this.data = data\n    this.left = left\n    this.right = right\n  }\n\n  toString(): string {\n    if (!this.left && !this.right) return '' + this.data\n    else if (!this.left) return `${this.data} (null, ${this.right.toString()})`\n    else if (!this.right) return `${this.data} (${this.left.toString()}, null)`\n    return `${this.data} (${this.left.toString()}, ${this.right.toString()})`\n  }\n}\n\n// O(log n)\nfunction checkRight(tn: TreeNodeWithParent): TreeNodeWithParent {\n  while (tn.left) {\n    tn = tn.left\n  }\n  return tn\n}\n\n// O(log n)\nfunction checkParent(tn: TreeNodeWithParent): TreeNodeWithParent {\n  let parent = tn.parent\n\n  while (parent) {\n    if (parent.data >= tn.data) {\n      return parent\n    }\n    parent = parent.parent\n  }\n\n  return null\n}\n\n// O(log n)\nfunction findNext(tn: TreeNodeWithParent): TreeNodeWithParent {\n  if (!tn) return null\n  if (tn.right) return checkRight(tn.right)\n  return checkParent(tn)\n}\n"
        },
        {
            "description": "Given two nodes in a binary tree and a reference to the root node find the first common ancestor of the two nodes without the use of state external to the tree itself (e.g. a data structure holding a collection of nodes). Assume that the nods appear in the tree, are unique to each other and the root.",
            "go": "package trees\n\n// see Minimal BST for TreeNode type def\n\n// O(n)\nfunc checkForNodes(tn, targetOne, targetTwo *TreeNode) (bool, bool) {\n\tif tn == nil {\n\t\treturn false, false\n\t} else if tn == targetOne {\n\t\t_, leftHasTwo := checkForNodes(tn.Left, targetOne, targetTwo)\n\t\t_, rightHasTwo := checkForNodes(tn.Right, targetOne, targetTwo)\n\t\treturn true, leftHasTwo || rightHasTwo\n\t} else if tn == targetTwo {\n\t\tleftHasOne, _ := checkForNodes(tn.Left, targetOne, targetTwo)\n\t\trightHasOne, _ := checkForNodes(tn.Right, targetOne, targetTwo)\n\t\treturn leftHasOne || rightHasOne, true\n\t}\n\n\tleftHasOne, leftHasTwo := checkForNodes(tn.Left, targetOne, targetTwo)\n\trightHasOne, rightHasTwo := checkForNodes(tn.Right, targetOne, targetTwo)\n\n\treturn leftHasOne || rightHasOne, leftHasTwo || rightHasTwo\n}\n\n// FirstCommonAncestor runs in O(n^2) -- O(n log n) for a balanced tree\nfunc FirstCommonAncestor(tn, targetOne, targetTwo *TreeNode) *TreeNode {\n\tleftHasOne, leftHasTwo := checkForNodes(tn.Left, targetOne, targetTwo)\n\trightHasOne, rightHasTwo := checkForNodes(tn.Right, targetOne, targetTwo)\n\n\tif (leftHasOne && rightHasTwo) || (leftHasTwo && rightHasOne) {\n\t\treturn tn\n\t} else if leftHasOne && leftHasTwo {\n\t\treturn FirstCommonAncestor(tn.Left, targetOne, targetTwo)\n\t}\n\n\treturn FirstCommonAncestor(tn.Right, targetOne, targetTwo)\n}\n",
            "number": "6",
            "python": "from trees_1 import TreeNode\n\n# for TreeNode class defintion see Minimal BST\n\n\n# O(n)\n# recursive scan of every node to determine existence of targets\n# given a node and a tuple of target nodes, return a tuple of boolean values\n# signifying whether or not each target appears in the tree\ndef check_for_nodes(node, targets):\n    if node == None:\n        return False, False\n    elif node is targets[0]:\n        hasOther = check_for_nodes(node.left, (targets[1],)) or check_for_nodes(\n            node.right, (targets[1],))\n        return True, hasOther[0]\n    elif len(targets) > 1 and node is targets[1]:\n        hasOther = check_for_nodes(node.left, (targets[0],)) or check_for_nodes(\n            node.right, (targets[0],))\n        return hasOther[0], True\n\n    check_left = check_for_nodes(node.left, targets)\n    check_right = check_for_nodes(node.right, targets)\n\n    return (check_left[0] or check_right[0]), (check_left[1] or check_right[1])\n\n\n# O(n log n) for a balanced tree\n# O(n^2) worst case\n# ---\n# O(log n) recursive calls to first_common_ancestor for a balanced tree\n# O(n) recursive calls to first_common_ancestor worst case\n# O(n) for each call to check for nodes\ndef first_common_ancestor(node, targets):\n    one_in_left, two_in_left = check_for_nodes(node.left, targets)\n    one_in_right, two_in_right = check_for_nodes(node.right, targets)\n\n    # if one target is found in one subtree and the other in the other\n    # then this is the first common ancestor\n    if (one_in_left and two_in_right) or (two_in_left and one_in_right):\n        return node\n    elif one_in_left and two_in_left:\n        return first_common_ancestor(node.left, targets)\n\n    # one_in_right and two_in_right\n    return first_common_ancestor(node.right, targets)\n",
            "stem": "trees_6",
            "title": "First Common Ancestor",
            "ts": "import { TreeNode } from './trees_1'\n\n// see Minimal BST for TreeNode class def\n\n// O(n)\nfunction checkForNodes(\n  tn: TreeNode,\n  targetOne: TreeNode,\n  targetTwo: TreeNode,\n): boolean[] {\n  if (!tn) return [false, false]\n\n  if (tn === targetOne) {\n    const [, hasOther] =\n      checkForNodes(tn.left, targetOne, targetTwo) ||\n      checkForNodes(tn.right, targetOne, targetTwo)\n    return [true, hasOther]\n  }\n\n  if (tn === targetTwo) {\n    const [hasOther] =\n      checkForNodes(tn.left, targetOne, targetTwo) ||\n      checkForNodes(tn.right, targetOne, targetTwo)\n    return [hasOther, true]\n  }\n\n  const [oneInLeft, twoInLeft] = checkForNodes(tn.left, targetOne, targetTwo)\n  const [oneInRight, twoInRight] = checkForNodes(tn.right, targetOne, targetTwo)\n\n  return [oneInLeft || oneInRight, twoInLeft || twoInRight]\n}\n\n// O(n^2) worst case\n// O(n log n) for a balanced tree\nfunction firstCommonAncestor(\n  tn: TreeNode,\n  targetOne: TreeNode,\n  targetTwo: TreeNode,\n): TreeNode {\n  const [oneInLeft, twoInLeft] = checkForNodes(tn.left, targetOne, targetTwo)\n  const [oneInRight, twoInRight] = checkForNodes(tn.right, targetOne, targetTwo)\n\n  if ((oneInLeft && twoInRight) || (oneInRight && twoInLeft)) return tn\n\n  if (oneInLeft && twoInLeft)\n    return firstCommonAncestor(tn.left, targetOne, targetTwo)\n\n  return firstCommonAncestor(tn.right, targetOne, targetTwo)\n}\n"
        },
        {
            "description": "A binary search tree was created by iterating over an array and inserting each element. Given a reference to the root of that tree and an assumption that all elements are distinct list every possible array that could've led to producing it.",
            "go": "package trees\n\n// see Minimal BST for TreeNode type def\n\nfunc constructDepthMap(tn *TreeNode, depth int, depthMap map[int][]int) {\n\tif tn == nil {\n\t\treturn\n\t}\n\n\tdepthMap[depth] = append(depthMap[depth], tn.Data)\n\tconstructDepthMap(tn.Left, depth+1, depthMap)\n\tconstructDepthMap(tn.Right, depth+1, depthMap)\n}\n\nfunc copy(ns []int) []int {\n\tclone := []int{}\n\n\tfor _, n := range ns {\n\t\tclone = append(clone, n)\n\t}\n\n\treturn clone\n}\n\nfunc swap(ns []int, i, j int) {\n\ttemp := ns[i]\n\tns[i] = ns[j]\n\tns[j] = temp\n}\n\nfunc permutations(ns []int, k int, acc *[][]int) {\n\tif k == len(ns) {\n\t\t*acc = append(*acc, copy(ns))\n\t} else {\n\t\tfor i := k; i < len(ns); i++ {\n\t\t\tswap(ns, i, k)\n\t\t\tpermutations(ns, k+1, acc)\n\t\t\tswap(ns, i, k)\n\t\t}\n\t}\n}\n\n// BSTSequences permutes each layer of the tree\n// to generate the sequences that could've produced it\nfunc BSTSequences(root *TreeNode) [][]int {\n\tdepthMap := map[int][]int{}\n\tconstructDepthMap(root, 0, depthMap)\n\tsequences := [][]int{[]int{root.Data}}\n\n\tfor d := 1; d < len(depthMap); d++ {\n\t\tappendedSequences := [][]int{}\n\t\tacc := [][]int{}\n\t\tpermutations(depthMap[d], 0, &acc)\n\n\t\tfor _, p := range acc {\n\t\t\tfor _, s := range sequences {\n\t\t\t\tsequence := append(s, p...)\n\t\t\t\tappendedSequences = append(appendedSequences, sequence)\n\t\t\t}\n\t\t}\n\n\t\tsequences = appendedSequences\n\t}\n\n\treturn sequences\n}\n",
            "number": "7",
            "python": "from trees_1 import TreeNode\nfrom collections import defaultdict\n\n# for TreeNode class defintion see Minimal BST\n\n# instantiate a dictionary int => list\n# traverse the tree while keeping track of the current depth\n# store all values for a given depth (starting at depth 0)\n# construct a series of lists where permutations\n# of the lists in the dictionary are concatenated in order\n# e.g. 1 => (2 => (4, 5), 3) would result in\n# depth 0 permutations: {[1]}\n# depth 1 permutations: {[2, 3], [3, 2]}\n# depth 2 permutations: {[4, 5], [5, 4]}\n# leading to the following set of concatenated lists:\n# {\n#   [1, 2, 3, 4, 5],\n#   [1, 2, 3, 5, 4],\n#   [1, 3, 2, 4, 5],\n#   [1, 3, 2, 5, 4]\n# }\n\n\ndef construct_depth_map(node, depth=0, depth_map=defaultdict(list)):\n    if not node:\n        return\n    depth_map[depth].append(node.data)\n    construct_depth_map(node.left, depth + 1, depth_map)\n    construct_depth_map(node.right, depth + 1, depth_map)\n\n    return depth_map\n\n\ndef permutations(a, k, acc):\n    if k == len(a):\n        permutation = a.copy()\n        acc.append(permutation)\n    else:\n        for i in range(k, len(a)):\n            # swap the ith and kth elements\n            a[k], a[i] = a[i], a[k]\n            # call permutations on the rest of the list\n            permutations(a, k + 1, acc)\n            # swap the elements back to their original position\n            # before incrementing i\n            a[k], a[i] = a[i], a[k]\n\n    return acc\n\n\ndef bst_sequences(root):\n    depth_map = construct_depth_map(root)\n    sequences = [[root.data]]\n\n    for d in range(1, len(depth_map)):\n        appended_sequences = []\n        for p in permutations(depth_map[d], 0, []):\n            for s in sequences:\n                appended_sequences.append(s + p)\n        sequences = appended_sequences\n\n    return sequences\n",
            "stem": "trees_7",
            "title": "BST Sequences",
            "ts": "import { TreeNode } from './trees_1'\n\n// see Minimal BST for TreeNode class def\n\nfunction constructDepthMap(\n  tn: TreeNode,\n  depth: number,\n  depthMap: { [key: number]: number[] },\n): { [key: number]: number[] } {\n  if (!tn) return\n\n  if (depthMap[depth]) {\n    depthMap[depth].push(tn.data)\n  } else {\n    depthMap[depth] = [tn.data]\n  }\n\n  constructDepthMap(tn.left, depth + 1, depthMap)\n  constructDepthMap(tn.right, depth + 1, depthMap)\n\n  return depthMap\n}\n\nfunction swap(ns: number[], i: number, j: number) {\n  const temp = ns[i]\n  ns[i] = ns[j]\n  ns[j] = temp\n}\n\nfunction permutations(ns: number[], k: number, acc: number[][]) {\n  if (k === ns.length) {\n    acc.push([...ns])\n  } else {\n    for (let i = k; i < ns.length; i++) {\n      swap(ns, i, k)\n      permutations(ns, k + 1, acc)\n      swap(ns, i, k)\n    }\n  }\n}\n\nfunction bstSequences(tn: TreeNode): number[][] {\n  const depthMap = constructDepthMap(tn, 0, {})\n  let sequences: number[][] = [[tn.data]]\n\n  for (let d = 1; d < Object.keys(depthMap).length; d++) {\n    const appendedSequences: number[][] = []\n    const ps: number[][] = []\n    permutations(depthMap[d], 0, ps)\n    for (const p of ps) {\n      for (const s of sequences) {\n        appendedSequences.push(s.concat(p))\n      }\n    }\n    sequences = appendedSequences\n  }\n\n  return sequences\n}\n"
        }
    ]
}