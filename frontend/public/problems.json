{
    "Linked Lists": [
        {
            "description": "Write a method to remove duplicates from an unsorted linked list. As a follow up write a method that does so without any additional memory allocation like storing the seen values in a hash table.",
            "go": "package linked\n\nimport \"fmt\"\n\n// Node is a node in a linked list\n// value could be any datatype, but Go does not support generics\ntype Node struct {\n\tValue int\n\tNext  *Node\n}\n\n// List wraps a head node\ntype List struct {\n\tHead *Node\n}\n\n// ToString prints a linked list\nfunc (l List) ToString() string {\n\ts := \"\"\n\tnode := l.Head\n\tfor node != nil {\n\t\ts = s + fmt.Sprintf(\"%d -> \", node.Value)\n\t\tnode = node.Next\n\t}\n\treturn s + \"nil\"\n}\n\n// RemoveDuplicatesTime runs in O(n)\nfunc RemoveDuplicatesTime(l List) {\n\tvalueSet := map[int]bool{}\n\tnode := l.Head\n\n\tfor node.Next != nil {\n\t\tif valueSet[node.Next.Value] {\n\t\t\tnode.Next = node.Next.Next\n\t\t} else {\n\t\t\tvalueSet[node.Next.Value] = true\n\t\t\tnode = node.Next\n\t\t}\n\t}\n}\n\n// RemoveDuplicatesSpace runs in O(1) space -- O(n^2) time\nfunc RemoveDuplicatesSpace(l List) {\n\tindexNode := l.Head\n\tvar cursorNode *Node\n\n\tfor indexNode.Next != nil {\n\t\tcursorNode = indexNode\n\t\tfor cursorNode.Next != nil {\n\t\t\tif cursorNode.Next.Value == indexNode.Value {\n\t\t\t\tcursorNode.Next = cursorNode.Next.Next\n\t\t\t} else {\n\t\t\t\tcursorNode = cursorNode.Next\n\t\t\t}\n\t\t}\n\t\tindexNode = indexNode.Next\n\t}\n}\n",
            "number": "1",
            "python": "class LinkedList:\n    def __init__(self, head):\n        self.head = head\n\n    def __repr__(self):\n        node = self.head\n        nodes = []\n        while node:\n            nodes.append(str(node.value))\n            node = node.next\n        return ' -> '.join(nodes + ['None'])\n\n\nclass Node:\n    def __init__(self, value, next):\n        self.value = value\n        self.next = next\n\n    def __repr__(self):\n        return str(self.value)\n\n\n# O(n)\ndef remove_duplicates_time(linked_list):\n    values = set()\n    node = linked_list.head\n\n    while node.next:\n        if node.next.value in values:\n            node.next = node.next.next\n        else:\n            values.add(node.next.value)\n            node = node.next\n\n\n# O(1) space -- O(n^2) time\ndef remove_duplicates_space(linked_list):\n    index_node = linked_list.head\n\n    while index_node.next:\n        cursor_node = index_node\n        while cursor_node.next:\n            if cursor_node.next.value == index_node.value:\n                cursor_node.next = cursor_node.next.next\n            else:\n                cursor_node = cursor_node.next\n        index_node = index_node.next\n",
            "stem": "linked_1",
            "title": "Remove Duplicates",
            "ts": "// Node already exists in JS\nexport class Node_ {\n  value: number\n  next: Node_\n\n  constructor(value: number, next: Node_) {\n    this.value = value\n    this.next = next\n  }\n}\n\nexport class LinkedList {\n  head: Node_\n\n  constructor(head: Node_) {\n    this.head = head\n  }\n\n  toString() {\n    let s = ''\n    let node = this.head\n    while (node) {\n      s = `${s}${node.value} -> `\n      node = node.next\n    }\n    return s + 'nil'\n  }\n}\n\n// O(n)\nfunction removeDuplicatesTime(l: LinkedList) {\n  const valueSet: Set<number> = new Set()\n  let node = l.head\n\n  while (node.next) {\n    if (valueSet.has(node.next.value)) {\n      node.next = node.next.next\n    } else {\n      valueSet.add(node.next.value)\n      node = node.next\n    }\n  }\n}\n\n// O(1) space -- O(n^2) time\nfunction removeDuplicatesSpace(l: LinkedList) {\n  let indexNode = l.head\n  let cursorNode\n\n  while (indexNode.next) {\n    cursorNode = indexNode\n    while (cursorNode.next) {\n      if (cursorNode.next.value === indexNode.value) {\n        cursorNode.next = cursorNode.next.next\n      } else {\n        cursorNode = cursorNode.next\n      }\n    }\n    indexNode = indexNode.next\n  }\n}\n"
        },
        {
            "description": "Write a method to find the kth to last element of singly linked list.",
            "go": "package linked\n\nimport \"fmt\"\n\n// see Remove Duplicates for List and Node type definitions\n\n// KthToLastElement runs in O(n)\nfunc KthToLastElement(l List, k int) *Node {\n\tleadNode := l.Head\n\tlagNode := l.Head\n\tleadIndex := 0\n\tlagIndex := 0\n\n\tfor leadNode != nil {\n\t\tleadNode = leadNode.Next\n\t\tleadIndex++\n\t\tif leadIndex > k {\n\t\t\tlagNode = lagNode.Next\n\t\t\tlagIndex++\n\t\t}\n\t}\n\n\tif leadIndex-lagIndex < k {\n\t\tfmt.Printf(\"List is not long enough to have a %d(st/nd/rd/th) to last element, returning the first node instead.\\n\", k)\n\t}\n\n\treturn lagNode\n}\n",
            "number": "2",
            "python": "# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef kth_to_last_element(linked_list, k):\n    # maintain a leading and lagging pointer\n    # lag will trail the lead by k\n    lead_node = linked_list.head\n    lag_node = linked_list.head\n    lead_index = 0\n    lag_index = 0\n\n    while lead_node:\n        lead_node = lead_node.next\n        lead_index += 1\n        if lead_index > k:\n            lag_node = lag_node.next\n            lag_index += 1\n\n    if lead_index - lag_index < k:\n        print('List is not long enough to have a %d(st/nd/rd/th) to last element, returning the first node instead.')\n\n    return lag_node\n",
            "stem": "linked_2",
            "title": "Kth to Last",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(n)\nfunction kthToLastElement(l: LinkedList, k: number): Node_ {\n  let leadNode: Node_ = l.head\n  let lagNode: Node_ = l.head\n  let leadIndex = 0\n  let lagIndex = 0\n\n  while (leadNode) {\n    leadNode = leadNode.next\n    leadIndex++\n    if (leadIndex > k) {\n      lagNode = lagNode.next\n      lagIndex++\n    }\n  }\n\n  if (leadIndex - lagIndex < k) {\n    console.log(\n      `List is not long enough to have a ${k}(st/nd/rd/th) to last element, returning the first node instead.`,\n    )\n  }\n\n  return lagNode\n}\n"
        },
        {
            "description": "Given a pointer to a node appearing somewhere in a linked list write a method to remove it. Assume no access to the head of the list and the element being removed is not the first or last element.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n\n// DeleteNode is O(1) -- see Python for comments\nfunc DeleteNode(n *Node) {\n\tn.Value = n.Next.Value\n\tn.Next = n.Next.Next\n}\n",
            "number": "3",
            "python": "# see Remove Duplicates for List and Node type definitions\n\n\n# O(1)\ndef delete_node(node):\n    # overwrite the value of this node with the next node\n    # then splice out the next node to remove the duplicate data\n\n    # assert that node.next exists from the problem statement\n    node.value = node.next.value\n    node.next = node.next.next\n\n    # note that this does not remove the reference to the node\n    # in fact it removes the reference to the next node\n    # it only ensures that the data in the list reflects the delete\n",
            "stem": "linked_3",
            "title": "Delete Node",
            "ts": "import { Node_ } from './linked_1'\n\n// O(1) -- see Python for comments\nfunction deleteNode(n: Node_) {\n  n.value = n.next.value\n  n.next = n.next.next\n}\n"
        },
        {
            "description": "Write method to generate a partitioned linked list from an input list and value such that all elements greater than or equal to the value appear after elements that are less than the value. Ordering does not matter, e.g. 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 with a supplied value of 5 outputs 3 -> 1 -> -> 2 -> 10 -> 5 -> 5 -> 8 where the partition exists between 2 and 10.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n\n// Partition runs in O(n)\nfunc Partition(l List, value int) *Node {\n\thead := l.Head\n\ttail := l.Head\n\tnode := l.Head\n\n\tfor node != nil {\n\t\tnext := node.Next\n\n\t\tif node.Value < value {\n\t\t\tnode.Next = head\n\t\t\thead = node\n\t\t} else {\n\t\t\ttail.Next = node\n\t\t\ttail = node\n\t\t}\n\n\t\tnode = next\n\t}\n\n\ttail.Next = nil\n\n\treturn head\n}\n",
            "number": "4",
            "python": "# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef partition(list, value):\n    head = list.head\n    tail = list.head\n    node = list.head\n\n    # O(n)\n    while node:\n        # keep a reference to the next node in the original list\n        next = node.next\n\n        if node.value < value:\n            # reassign node to point at the previous head\n            node.next = head\n            # reassign the head of the list to this node\n            head = node\n        else:\n            # push this node on to the end of the list\n            tail.next = node\n            # reassign the tail to this node\n            tail = node\n\n        # move on to the next node in the original list\n        node = next\n\n    # clip the tail\n    tail.next = None\n\n    return head\n",
            "stem": "linked_4",
            "title": "Partition",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(n)\nfunction partition(l: LinkedList, value: number): Node_ {\n  let head: Node_ = l.head\n  let tail: Node_ = l.head\n  let node: Node_ = l.head\n\n  while (node) {\n    const next = node.next\n\n    if (node.value < value) {\n      node.next = head\n      head = node\n    } else {\n      tail.next = node\n      tail = node\n    }\n\n    node = next\n  }\n\n  tail.next = null\n\n  return head\n}\n"
        },
        {
            "description": "Given two numbers represented by linked lists where each number is a digit. Produce the sum of these numbers a new linked list. Generate one method that handles right to left ordering: 6 -> 1 -> 7 => 716 and one that handles left to right ordering 6 -> 1 -> 7 => 617.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n\n// Stack implements a LIFO data structure\ntype Stack struct {\n\tns []*Node\n}\n\n// RightToLeftSum is O(m + n)\nfunc RightToLeftSum(l1, l2 List) List {\n\tn1 := l1.Head\n\tn2 := l2.Head\n\t// assumes length of each list is at least 1\n\tnextValue := n1.Value + n2.Value\n\tsumNode := &Node{Value: nextValue % 10, Next: nil}\n\tsumList := List{Head: sumNode}\n\tcarry := nextValue / 10\n\n\tfor n1.Next != nil || n2.Next != nil {\n\t\tif n1.Next == nil {\n\t\t\tnextValue = n2.Next.Value + carry\n\t\t\tn2 = n2.Next\n\t\t} else if n2.Next == nil {\n\t\t\tnextValue = n1.Next.Value + carry\n\t\t\tn1 = n1.Next\n\t\t} else {\n\t\t\tnextValue = n1.Next.Value + n2.Next.Value + carry\n\t\t\tn1 = n1.Next\n\t\t\tn2 = n2.Next\n\t\t}\n\n\t\tcarry = nextValue / 10\n\t\tsumNode.Next = &Node{Value: nextValue % 10, Next: nil}\n\t\tsumNode = sumNode.Next\n\t}\n\n\tif carry == 1 {\n\t\tsumNode.Next = &Node{Value: 1, Next: nil}\n\t}\n\n\treturn sumList\n}\n\n// ListToStack is O(n)\nfunc (l List) ListToStack() Stack {\n\tstack := Stack{}\n\tnode := l.Head\n\tfor node != nil {\n\t\tstack.ns = append(stack.ns, node)\n\t\tnode = node.Next\n\t}\n\treturn stack\n}\n\n// for both stack methods it is important to pass by reference (*Stack)\n\n// Len is O(1)\nfunc (s *Stack) Len() int {\n\treturn len(s.ns)\n}\n\n// Pop is O(1)\nfunc (s *Stack) Pop() *Node {\n\tnode := s.ns[len(s.ns)-1]\n\ts.ns = s.ns[0 : len(s.ns)-1]\n\treturn node\n}\n\n// LeftToRightSum is O(m + n)\nfunc LeftToRightSum(l1, l2 List) List {\n\tstack1 := l1.ListToStack()\n\tstack2 := l2.ListToStack()\n\n\tvar head *Node\n\tvar node *Node\n\tvar nextValue int\n\tcarry := 0\n\n\tfor stack1.Len() > 0 || stack2.Len() > 0 {\n\t\tif stack1.Len() == 0 {\n\t\t\tnode = stack2.Pop()\n\t\t\tnextValue = node.Value + carry\n\t\t\tnode.Value = nextValue % 10\n\t\t\tnode.Next = head\n\t\t} else if stack2.Len() == 0 {\n\t\t\tnode = stack1.Pop()\n\t\t\tnextValue = node.Value + carry\n\t\t\tnode.Value = nextValue % 10\n\t\t\tnode.Next = head\n\t\t} else {\n\t\t\tnode1 := stack1.Pop()\n\t\t\tnode2 := stack2.Pop()\n\t\t\tnextValue = node1.Value + node2.Value + carry\n\t\t\tnode = &Node{Value: nextValue % 10, Next: head}\n\t\t}\n\n\t\tcarry = nextValue / 10\n\t\thead = node\n\t}\n\n\tif carry == 1 {\n\t\tnode := &Node{Value: 1, Next: head}\n\t\thead = node\n\t}\n\n\treturn List{Head: head}\n}\n",
            "number": "5",
            "python": "from linked_lists_1 import LinkedList, Node\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(m + n)\ndef right_to_left_sum(l1, l2):\n    # step through the lists at the same time performing addition\n    # and carrying the one as needed\n    n1 = l1.head\n    n2 = l2.head\n    # assumes length of each list is at least 1\n    next_value = n1.value + n2.value\n    carry = next_value // 10\n    sum_node = Node(next_value % 10, None)\n    sum_list = LinkedList(sum_node)\n\n    # O(m + n)\n    while n1.next or n2.next:\n        if not n1.next:\n            next_value = n2.next.value + carry\n        elif not n2.next:\n            next_value = n1.next.value + carry\n        else:\n            next_value = n1.next.value + n2.next.value + carry\n\n        carry = next_value // 10\n\n        sum_node.next = Node(next_value % 10, None)\n        sum_node = sum_node.next\n\n        n1 = n1.next if n1.next else n1\n        n2 = n2.next if n2.next else n2\n\n    if carry == 1:\n        sum_node.next = Node(1, None)\n\n    return sum_list\n\n\n# O(n)\ndef list_to_stack(l):\n    stack = []\n    node = l.head\n    while node:\n        stack.append(node)\n        node = node.next\n\n    return stack\n\n\n# O(m + n)\ndef left_to_right_sum(l1, l2):\n    # O(n)\n    stack1 = list_to_stack(l1)\n    # O(m)\n    stack2 = list_to_stack(l2)\n\n    head = None\n    carry = 0\n\n    # O(m + n)\n    while stack1 or stack2:\n        if not stack1:\n            node = stack2.pop()\n            next_value = node.value + carry\n            node.value = next_value % 10\n            node.next = head\n        elif not stack2:\n            node = stack1.pop()\n            next_value = node.value + carry\n            node.value = next_value % 10\n            node.next = head\n        else:\n            node1 = stack1.pop()\n            node2 = stack2.pop()\n            next_value = node1.value + node2.value + carry\n            node = Node(next_value % 10, head)\n\n        carry = next_value // 10\n        head = node\n\n    if carry == 1:\n        node = Node(1, head)\n        head = node\n\n    return LinkedList(head)\n",
            "stem": "linked_5",
            "title": "Sum Lists",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(m + n)\nfunction rightToLeftSum(l1: LinkedList, l2: LinkedList): LinkedList {\n  let n1: Node_ = l1.head\n  let n2: Node_ = l2.head\n  let nextValue = n1.value + n2.value\n  let sumNode = new Node_(nextValue % 10, null)\n  const sumList = new LinkedList(sumNode)\n  let carry = Math.floor(nextValue / 10)\n\n  while (n1.next || n2.next) {\n    if (!n1.next) {\n      nextValue = n2.next.value + carry\n      n2 = n2.next\n    } else if (!n2.next) {\n      nextValue = n1.next.value + carry\n      n1 = n1.next\n    } else {\n      nextValue = n1.next.value + n2.next.value + carry\n      n1 = n1.next\n      n2 = n2.next\n    }\n\n    carry = Math.floor(nextValue / 10)\n    sumNode.next = new Node_(nextValue % 10, null)\n    sumNode = sumNode.next\n  }\n\n  if (carry === 1) {\n    sumNode.next = new Node_(1, null)\n  }\n\n  return sumList\n}\n\n// O(n)\nfunction listToStack(l: LinkedList): Node_[] {\n  const stack: Node_[] = []\n  let node = l.head\n  while (node) {\n    stack.push(node)\n    node = node.next\n  }\n  return stack\n}\n\n// O(m + n)\nfunction leftToRightSum(l1: LinkedList, l2: LinkedList): LinkedList {\n  const stack1 = listToStack(l1)\n  const stack2 = listToStack(l2)\n  let head: Node_\n  let node: Node_\n  let nextValue\n  let carry = 0\n\n  while (stack1.length > 0 || stack2.length > 0) {\n    if (stack1.length === 0) {\n      node = stack2.pop()\n      nextValue = node.value + carry\n      node.value = nextValue % 10\n      node.next = head\n    } else if (stack2.length === 0) {\n      node = stack1.pop()\n      nextValue = node.value + carry\n      node.value = nextValue % 10\n      node.next = head\n    } else {\n      const node1 = stack1.pop()\n      const node2 = stack2.pop()\n      nextValue = node1.value + node2.value + carry\n      node = new Node_(nextValue % 10, head)\n    }\n\n    carry = Math.floor(nextValue / 10)\n    head = node\n  }\n\n  if (carry === 1) {\n    node = new Node_(1, head)\n    head = node\n  }\n\n  return new LinkedList(head)\n}\n"
        },
        {
            "description": "Write a method to determine if a linked list is a palindrome.",
            "go": "package linked\n\n// see Remove Duplicates for List and Node type definitions\n// see Sum Lists for stack type definition and methods\n\n// IsPalindrome is O(n)\nfunc IsPalindrome(l List) bool {\n\tlistNode := l.Head\n\tstack := l.ListToStack()\n\tlistLength := stack.Len()\n\n\tfor stack.Len() >= listLength/2 {\n\t\tstackNode := stack.Pop()\n\t\tif stackNode.Value != listNode.Value {\n\t\t\treturn false\n\t\t}\n\t\tlistNode = listNode.Next\n\t}\n\n\treturn true\n}\n",
            "number": "6",
            "python": "from linked_lists_1 import LinkedList, Node\n\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef list_to_stack(l):\n    stack = []\n    node = l.head\n\n    while node:\n        stack.append(node)\n        node = node.next\n\n    return stack\n\n\n# O(n)\ndef is_palindrome(l):\n    list_node = l.head\n    # O(n) create a stack to represent the list in reverse order\n    stack = list_to_stack(l)\n    list_length = len(stack)\n\n    # O(n) compare the stack to the list\n    while len(stack) >= list_length // 2:\n        stack_node = stack.pop()\n        if stack_node.value != list_node.value:\n            return False\n        list_node = list_node.next\n\n    return True\n",
            "stem": "linked_6",
            "title": "Palindrome",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(n)\nfunction listToStack(l: LinkedList): Node_[] {\n  const stack: Node_[] = []\n  let node = l.head\n  while (node) {\n    stack.push(node)\n    node = node.next\n  }\n  return stack\n}\n\n// O(n)\nfunction isPalindrome(l: LinkedList): boolean {\n  let listNode: Node_ = l.head\n  const stack = listToStack(l)\n  const listLength = stack.length\n\n  while (stack.length >= Math.floor(listLength / 2)) {\n    const stackNode = stack.pop()\n    if (stackNode.value !== listNode.value) {\n      return false\n    }\n    listNode = listNode.next\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Given two singly linked list determine if they share a node (by reference). If the lists intersect return the intersecting node.",
            "go": "package linked\n\n// FindIntersection is O(m + n)\nfunc FindIntersection(l1, l2 List) *Node {\n\tm := map[*Node]bool{}\n\n\tnode := l1.Head\n\tfor node != nil {\n\t\tm[node] = true\n\t\tnode = node.Next\n\t}\n\n\tnode = l2.Head\n\tfor node != nil {\n\t\tif m[node] {\n\t\t\treturn node\n\t\t}\n\t\tnode = node.Next\n\t}\n\n\treturn nil\n}\n",
            "number": "7",
            "python": "from linked_lists_1 import LinkedList, Node\n\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(m + n) time -- requires additional space for the set\ndef find_intersection(l1, l2):\n    # could do this in O(m + n) without the set\n    # by traversing to determine length of each and if the tail nodes are the same\n    # then traverse both lists starting at the difference between the lengths for the longer list\n    # effectively have the same distance between the tail and the starting point for each list\n    # compare each next node and the first node that is the same is the intersection\n\n    list1_nodes = set()\n\n    node = l1.head\n    while node:\n        list1_nodes.add(node)\n        node = node.next\n\n    node = l2.head\n    while node:\n        if node in list1_nodes:\n            return node\n        node = node.next\n",
            "stem": "linked_7",
            "title": "Intersection",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// see Remove Duplicates for List and Node type definitions\n\n// O(m + n)\nfunction findIntersection(l1: LinkedList, l2: LinkedList): Node_ {\n  const nodeSet: Set<Node_> = new Set()\n\n  let node = l1.head\n  while (node) {\n    nodeSet.add(node)\n    node = node.next\n  }\n\n  node = l2.head\n  while (node) {\n    if (nodeSet.has(node)) {\n      return node\n    }\n    node = node.next\n  }\n\n  return null\n}\n"
        },
        {
            "description": "Given a linked list that loops back on itself, implement an algorithm that returns the node at the beginning of the loop. Next, as a more difficult task implement an algorithm that only relies on references to nodes and does not rely on any state outside of the linked list.",
            "go": "package linked\n\n// FindLoopStart is O(n)\nfunc FindLoopStart(l List) *Node {\n\tm := map[*Node]bool{}\n\tnode := l.Head\n\n\tfor node != nil {\n\t\tif m[node] {\n\t\t\treturn node\n\t\t}\n\t\tm[node] = true\n\t\tnode = node.Next\n\t}\n\n\treturn nil\n}\n\n// FindLoopStartHard is O(n)\n// see comments in Python solution\nfunc FindLoopStartHard(l List) *Node {\n\tfast := l.Head\n\tslow := l.Head\n\n\tfast = fast.Next.Next\n\tslow = slow.Next\n\n\tfor fast != slow {\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t}\n\n\tslow = l.Head\n\n\tfor fast != slow {\n\t\tfast = fast.Next\n\t\tslow = slow.Next\n\t}\n\n\treturn fast\n}\n",
            "number": "8",
            "python": "from linked_lists_1 import LinkedList, Node\n\n# see Remove Duplicates for List and Node type definitions\n\n\n# O(n)\ndef find_loop_start(l):\n    visited = set()\n    node = l.head\n    while node:\n        if node in visited:\n            return node\n        visited.add(node)\n        node = node.next\n\n\n# let k be the distance between head and the start of the loop\n# let s be a slow pointer that moves one node every step\n# let f be a fast pointer that moves two nodes every step\n# let l be the length of the loop\n\n# when s has moved k and enters the loop\n# f is k steps into the loop, since it moved a distance of 2k\n# since the loop is a circular path and we know nothing about the length of the loop\n# compared to the distance between the head and the start of the loop\n# f is actually a distance k % l past the start of the loop when s gets there\n# having gone around the loop 0 or more times\n\n# let K = k % l\n# once both pointers are in the loop f gets 1 node closer to s every step\n# f is l - K steps behind s and the two will collide after exactly l - K steps\n# since s was at the start of the loop we can equivalently say that they will\n# collide at a distance of K from the start of the loop\n\n# since K = k % l, we can represent this as K + m * l = k for any integer m\n# since 1 degree on a circle is the same position as 361 degrees on a circle\n# we can say that a distance of K from the start is the same as a distance of k\n\n# knowing that the collision point is a k nodes back from the start of the loop\n# and k nodes from the head of the list we can traverse two pointers\n# one from head and the other from the node at which f and s collided\n# the node at which these two pointers collide must be the start of the loop\n\ndef find_loop_start_hard(l):\n    fast = l.head\n    slow = l.head\n\n    # take the first step (i.e. do while)\n    fast = fast.next.next\n    slow = slow.next\n\n    # \"is\" provides memory reference equivalence\n    while fast is not slow:\n        fast = fast.next.next\n        slow = slow.next\n\n    head_cursor = l.head\n    collision_cursor = fast\n\n    while head_cursor is not collision_cursor:\n        head_cursor = head_cursor.next\n        collision_cursor = collision_cursor.next\n\n    return head_cursor\n",
            "stem": "linked_8",
            "title": "Loop Detection",
            "ts": "import { LinkedList, Node_ } from './linked_1'\n\n// findLoopStart is O(n)\nfunction findLoopStart(l: LinkedList): Node_ {\n  const visited: Set<Node_> = new Set()\n  let node = l.head\n\n  while (node) {\n    if (visited.has(node)) {\n      return node\n    }\n    visited.add(node)\n    node = node.next\n  }\n}\n\n// findLoopStartHard is O(n)\n// see comments in Python solution\nfunction findLoopStartHard(l: LinkedList): Node_ {\n  let fast = l.head\n  let slow = l.head\n\n  fast = fast.next.next\n  slow = slow.next\n\n  while (fast !== slow) {\n    fast = fast.next.next\n    slow = slow.next\n  }\n\n  slow = l.head\n\n  while (fast !== slow) {\n    fast = fast.next\n    slow = slow.next\n  }\n\n  return fast\n}\n"
        }
    ],
    "Matrices": [
        {
            "description": "Given an image represented by an NxN matrix where each pixel is encoded as an integer, write a method to perform a 90 degree rotation in place (i.e. do not create a new matrix).",
            "go": "package iterables\n\n// RotateMatrix runs in O(n^2)\nfunc RotateMatrix(m [][]int) {\n\tfor i := 0; i < len(m)/2; i++ {\n\t\tfor j := i; j < len(m)-i-1; j++ {\n\t\t\t// slices are pointers to underlying arrays\n\t\t\t// so while everything is Go is pass by value, this is already\n\t\t\t// a reference and the modifications will occur in place\n\t\t\trotateCell(m, m[i][j], [2]int{j, len(m) - i - 1}, [2]int{i, j})\n\t\t}\n\t}\n}\n\nfunc rotateCell(m [][]int, value int, destination, start [2]int) {\n\tpreviousValue := m[destination[0]][destination[1]]\n\tm[destination[0]][destination[1]] = value\n\n\t// base case\n\tif destination[0] == start[0] && destination[1] == start[1] {\n\t\treturn\n\t}\n\n\trotateCell(m, previousValue, [2]int{destination[1], len(m) - destination[0] - 1}, start)\n}\n",
            "number": "1",
            "python": "# O(n^2) for an n x n matrix\ndef rotate_matrix(m):\n    # given a cell (i, j) the destination cell is (j, n - i - 1) for an n x n matrix\n\n    # assume m is represented by a 2D list of integers\n    # nested for loop is O(n^2)\n    # in this loop \"i\" represents the layer\n    # in an n x n matrix there are floor(n / 2) layers to rotate\n    for i in range(len(m) // 2):\n        for j in range(i, len(m) - i - 1):\n            # results in 4 recursive calls\n            rotate_cell(m, m[i][j], (j, len(m) - i - 1), (i, j))\n\n\n# rotate_cell is a recursive helper that sets the value of\n# of the destination cell to the supplied value\n# rotate_cell will be called 4 times before destination == start\ndef rotate_cell(m, value, destination, start):\n    previous_value = m[destination[0]][destination[1]]\n    m[destination[0]][destination[1]] = value\n\n    # base case\n    if destination == start:\n        return\n\n    rotate_cell(m, previous_value,\n                (destination[1], len(m) - destination[0] - 1), start)\n",
            "stem": "matrices_1",
            "title": "Matrix Rotation",
            "ts": "// O(n^2)\nfunction rotateMatrix(m: number[][]) {\n  // nested loop is O(n^2)\n  for (let i = 0; i < Math.floor(m.length / 2); i++) {\n    for (let j = i; j < m.length - i - 1; j++) {\n      rotateCell(m, m[i][j], [j, m.length - i - 1], [i, j])\n    }\n  }\n}\n\n// O(1) for each rotation with 4 recursive calls\nfunction rotateCell(\n  m: number[][],\n  value: number,\n  destination: number[],\n  start: number[],\n) {\n  const previousValue = m[destination[0]][destination[1]]\n  m[destination[0]][destination[1]] = value\n\n  if (destination[0] === start[0] && destination[1] === start[1]) {\n    return\n  }\n\n  rotateCell(\n    m,\n    previousValue,\n    [destination[1], m.length - destination[0] - 1],\n    start,\n  )\n}\n"
        },
        {
            "description": "Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.",
            "go": "package iterables\n\n// ZeroMatrix runs in O(nm)\nfunc ZeroMatrix(m [][]int) {\n\tzeroRows := map[int]bool{}\n\tzeroColumns := map[int]bool{}\n\n\tfor i := 0; i < len(m); i++ {\n\t\tfor j := 0; j < len(m[0]); j++ {\n\t\t\tif m[i][j] == 0 {\n\t\t\t\tzeroRows[i] = true\n\t\t\t\tzeroColumns[j] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := 0; i < len(m); i++ {\n\t\tfor j := 0; j < len(m[0]); j++ {\n\t\t\tif zeroRows[i] || zeroRows[j] {\n\t\t\t\tm[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n}\n",
            "number": "2",
            "python": "# O(mn) where m and n are the dimensions of the matrix\ndef zero_matrix(m):\n    zero_rows = set()\n    zero_columns = set()\n\n    # O(mn)\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            if m[i][j] == 0:\n                zero_rows.add(i)\n                zero_columns.add(j)\n    # O(mn)\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            # O(1) lookup by using sets\n            if i in zero_rows or j in zero_columns:\n                m[i][j] = 0\n",
            "stem": "matrices_2",
            "title": "Zero Matrix",
            "ts": "// O(mn)\nfunction zeroMatrix(m: number[][]) {\n  const zeroRows: Set<number> = new Set()\n  const zeroColumns: Set<number> = new Set()\n\n  for (let i = 0; i < m.length; i++) {\n    for (let j = 0; j < m[0].length; j++) {\n      if (m[i][j] === 0) {\n        zeroRows.add(i)\n        zeroColumns.add(j)\n      }\n    }\n  }\n\n  for (let i = 0; i < m.length; i++) {\n    for (let j = 0; j < m[0].length; j++) {\n      if (zeroRows.has(i) || zeroColumns.has(j)) {\n        m[i][j] = 0\n      }\n    }\n  }\n}\n"
        }
    ],
    "Stacks": [
        {
            "description": "Implement a stack that provides push, pop, and min in O(1).",
            "go": "package stacks\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// MinStack is LIFO data structure\n// supporting O(1) push, pop, and min\ntype MinStack struct {\n\tTop      *MinFrame\n\tMinFrame *MinFrame\n}\n\n// ToString provides a string representation for a stack\nfunc (s *MinStack) ToString() string {\n\tframes := []string{}\n\ttop := s.Top\n\n\tfor top != nil {\n\t\tframes = append(frames, top.ToString())\n\t\ttop = top.Next\n\t}\n\n\tif len(frames) > 0 {\n\t\tss := []string{\"top\"}\n\t\tss = append(ss, frames...)\n\t\tss = append(ss, \"bottom\")\n\t\tmin := \"None\"\n\n\t\tif s.MinFrame != nil {\n\t\t\tmin = strconv.Itoa(s.MinFrame.Data)\n\t\t} else {\n\t\t\tmin = \"nil\"\n\t\t}\n\n\t\treturn fmt.Sprintf(\"%s; Min: %s\", strings.Join(ss, \" -> \"), min)\n\t}\n\n\treturn \"empty stack\"\n}\n\n// Push O(1)\nfunc (s *MinStack) Push(data int) {\n\tframe := &MinFrame{Data: data, Next: s.Top}\n\n\tif s.MinFrame != nil {\n\t\tif data < s.MinFrame.Data {\n\t\t\tframe.PreviousMinFrame = s.MinFrame\n\t\t\ts.MinFrame = frame\n\t\t}\n\t} else {\n\t\ts.MinFrame = frame\n\t}\n\n\ts.Top = frame\n}\n\n// Pop O(1)\nfunc (s *MinStack) Pop() int {\n\tif s.Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\tif s.Top == s.MinFrame {\n\t\ts.MinFrame = s.Top.PreviousMinFrame\n\t}\n\n\tframe := s.Top\n\ts.Top = s.Top.Next\n\n\treturn frame.Data\n}\n\n// Min O(1)\nfunc (s *MinStack) Min() int {\n\tif s.Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\treturn s.MinFrame.Data\n}\n\n// MinFrame represents a single stack frame for a MinStack\n// using int for the data type out of convenience\ntype MinFrame struct {\n\tData             int\n\tNext             *MinFrame\n\tPreviousMinFrame *MinFrame\n}\n\n// ToString provides a string representation for a stack frame\nfunc (f *MinFrame) ToString() string {\n\treturn fmt.Sprintf(\"[ %d ]\", f.Data)\n}\n",
            "number": "1",
            "python": "class MinStack:\n    def __init__(self, top=None, min_frame=None):\n        self.top = top\n        self.min_frame = min_frame\n\n    def __repr__(self):\n        frames = []\n        top = self.top\n\n        while top:\n            frames.append(str(top))\n            top = top.next\n\n        # [] is falsy in Python\n        if frames:\n            return f'{\" -> \".join([\"top\"] + frames + [\"bottom\"])}; Min: {self.min_frame.data if self.min_frame else \"None\"}'\n\n        return 'empty stack'\n\n    def push(self, data):\n        frame = MinFrame(data, self.top)\n\n        # assumes that \"data\" is comparable to other \"data\" using standard operators\n        if self.min_frame:\n            if data < self.min_frame.data:\n                frame.previous_min_frame = self.min_frame\n                self.min_frame = frame\n        else:\n            self.min_frame = frame\n\n        self.top = frame\n\n    def pop(self):\n        if not self.top:\n            raise Exception('stack is empty')\n\n        if self.top is self.min_frame:\n            self.min_frame = self.top.previous_min_frame\n\n        frame = self.top\n        self.top = self.top.next\n\n        return frame.data\n\n    def min(self):\n        if not self.top:\n            raise Exception('stack is empty')\n\n        return self.min_frame.data\n\n\nclass MinFrame:\n    def __init__(self, data=None, next=None, previous_min_frame=None):\n        self.data = data\n        self.next = next\n        self.previous_min_frame = previous_min_frame\n\n    def __repr__(self):\n        return f'[ {self.data} ]'\n",
            "stem": "stacks_1",
            "title": "Stack Min",
            "ts": "class MinStack {\n  top: MinFrame\n  minFrame: MinFrame\n\n  constructor(top?: MinFrame, minFrame?: MinFrame) {\n    this.top = top\n    this.minFrame = minFrame\n  }\n\n  toString() {\n    const frames: string[] = []\n    let top = this.top\n\n    while (top) {\n      frames.push(top.toString())\n      top = top.next\n    }\n\n    if (frames.length > 0) {\n      const stackStrings = ['top', ...frames, 'bottom']\n      const min = this.minFrame ? this.minFrame.data : 'null'\n      return `${stackStrings.join(' -> ')}; Min: ${min}`\n    }\n\n    return 'empty stack'\n  }\n\n  push(data: number) {\n    const frame = new MinFrame(data, this.top)\n\n    if (this.minFrame) {\n      if (data < this.minFrame.data) {\n        frame.previousMinFrame = this.minFrame\n        this.minFrame = frame\n      }\n    } else {\n      this.minFrame = frame\n    }\n\n    this.top = frame\n  }\n\n  pop(): number {\n    if (!this.top) {\n      throw 'stack is empty'\n    }\n\n    if (this.top === this.minFrame) {\n      this.minFrame = this.top.previousMinFrame\n    }\n\n    const frame = this.top\n    this.top = this.top.next\n\n    return frame.data\n  }\n\n  min(): number {\n    if (!this.top) {\n      throw 'stack is empty'\n    }\n\n    return this.minFrame.data\n  }\n}\n\nclass MinFrame {\n  data: number\n  next: MinFrame\n  previousMinFrame: MinFrame\n\n  constructor(data?: number, next?: MinFrame, previousMinFrame?: MinFrame) {\n    this.data = data\n    this.next = next\n    this.previousMinFrame = previousMinFrame\n  }\n\n  toString() {\n    return `[ ${this.data} ]`\n  }\n}\n"
        },
        {
            "description": "Implement a data structure that maintains multiple stacks with a fixed capacity. When the stack overflows create a new stack to house the new entry. When a stack is consumed remove it from the structure. Also implement a popAt(i) method that removes the top item from the ith stack.",
            "go": "package stacks\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// StackSet is LIFO data structure\n// with multiple stacks\n// supporting O(1) push, pop, and popAt\ntype StackSet struct {\n\tStacks        []*Stack\n\tIndex         int\n\tStackCapacity int\n}\n\n// ToString provides a string representation for a stack set\nfunc (ss *StackSet) ToString() string {\n\tstacks := \"\"\n\n\tfor i, s := range ss.Stacks {\n\t\tstacks += fmt.Sprintf(\"%d: %s\\n\", i, s.ToString())\n\t}\n\n\treturn stacks\n}\n\n// Pop is O(1)\nfunc (ss *StackSet) Pop() int {\n\tif len(ss.Stacks) == 0 {\n\t\tpanic(\"stack set is empty\")\n\t}\n\n\tfor ss.Stacks[ss.Index].Top == nil {\n\t\tss.Stacks = ss.Stacks[:len(ss.Stacks)-1]\n\t\tss.Index--\n\n\t\tif ss.Index == -1 {\n\t\t\tss.Index = 0\n\t\t\tpanic(\"stack set is empty\")\n\t\t}\n\t}\n\n\treturn ss.Stacks[ss.Index].Pop()\n}\n\n// Push is O(1)\nfunc (ss *StackSet) Push(data int) {\n\tif len(ss.Stacks) == 0 {\n\t\tss.Stacks = append(ss.Stacks, &Stack{})\n\t\tss.Push(data)\n\t} else if ss.Stacks[ss.Index].Length == ss.StackCapacity {\n\t\tss.Index++\n\t\tss.Stacks = append(ss.Stacks, &Stack{})\n\t\tss.Push(data)\n\t} else {\n\t\tss.Stacks[ss.Index].Push(data)\n\t}\n}\n\n// PopAt is O(1)\n// this does not move frames between stacks\nfunc (ss *StackSet) PopAt(i int) int {\n\tif i >= len(ss.Stacks) {\n\t\tpanic(\"index out of bounds\")\n\t}\n\n\tif ss.Stacks[i].Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\treturn ss.Stacks[i].Pop()\n}\n\n// Stack is a LIFO data structure\ntype Stack struct {\n\tTop    *Frame\n\tLength int\n}\n\n// ToString provides a string representation for a stack\nfunc (s *Stack) ToString() string {\n\tframes := []string{}\n\ttop := s.Top\n\n\tfor top != nil {\n\t\tframes = append(frames, top.ToString())\n\t\ttop = top.Next\n\t}\n\n\tif len(frames) > 0 {\n\t\tss := []string{\"top\"}\n\t\tss = append(ss, frames...)\n\t\tss = append(ss, \"bottom\")\n\n\t\treturn strings.Join(ss, \" -> \")\n\t}\n\n\treturn \"empty stack\"\n}\n\n// Push O(1)\nfunc (s *Stack) Push(data int) {\n\tframe := &Frame{Data: data, Next: s.Top}\n\ts.Top = frame\n\ts.Length++\n}\n\n// Pop O(1)\nfunc (s *Stack) Pop() int {\n\tif s.Top == nil {\n\t\tpanic(\"stack is empty\")\n\t}\n\n\tframe := s.Top\n\ts.Top = s.Top.Next\n\ts.Length--\n\n\treturn frame.Data\n}\n\n// Frame is a single stack frame\ntype Frame struct {\n\tData int\n\tNext *Frame\n}\n\n// ToString provides a string representation for a stack frame\nfunc (f *Frame) ToString() string {\n\treturn fmt.Sprintf(\"[ %d ]\", f.Data)\n}\n",
            "number": "2",
            "python": "class StackSet:\n    def __init__(self, stack_capacity=None):\n        self.stacks = []\n        self.index = None\n        self.stack_capacity = stack_capacity\n\n    def __repr__(self):\n        stacks = \"\"\n\n        for i, s in enumerate(self.stacks):\n            stacks += f'{i}: {s}\\n'\n\n        return stacks\n\n    def pop(self):\n        if self.index == None:\n            raise Exception('stack set is empty')\n\n        # find a non-empty stack\n        # necessary to support popAt(i)\n        while not self.stacks[self.index].top:\n            # Python list built in pop\n            self.stacks.pop()\n            self.index -= 1\n\n            if self.index == -1:\n                self.index = None\n                raise Exception('stack set is empty')\n\n        return self.stacks[self.index].pop()\n\n    def push(self, data):\n        if self.index == None:\n            self.index = 0\n            self.stacks.append(Stack())\n            self.push(data)\n        elif self.stacks[self.index].length == self.stack_capacity:\n            self.index += 1\n            self.stacks.append(Stack())\n            self.push(data)\n        else:\n            self.stacks[self.index].push(data)\n\n    def popAt(self, i):\n        if i >= len(self.stacks):\n            raise IndexError\n\n        if not self.stacks[i].top:\n            raise Exception('stack is empty')\n\n        return self.stacks[i].pop()\n\n\nclass Stack:\n    def __init__(self, top=None):\n        self.top = top\n        self.length = 0\n\n    def __repr__(self):\n        frames = []\n        top = self.top\n\n        while top:\n            frames.append(str(top))\n            top = top.next\n\n        if frames:\n            return f'{\" -> \".join([\"top\"] + frames + [\"bottom\"])}'\n\n        return 'empty stack'\n\n    def push(self, data):\n        frame = Frame(data, self.top)\n        self.top = frame\n        self.length += 1\n\n    def pop(self):\n        if not self.top:\n            raise Exception('stack is empty')\n\n        frame = self.top\n        self.top = self.top.next\n        self.length -= 1\n\n        return frame.data\n\n\nclass Frame:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n\n    def __repr__(self):\n        return f'[ {self.data} ]'\n",
            "stem": "stacks_2",
            "title": "Stack Set",
            "ts": "class StackSet {\n  stacks: Stack[]\n  index: number\n  stackCapacity: number\n\n  constructor(stackCapacity: number) {\n    this.stacks = []\n    this.index = 0\n    this.stackCapacity = stackCapacity\n  }\n\n  toString(): string {\n    let stacks = ''\n\n    this.stacks.forEach((s, i) => {\n      stacks += `${i}: ${s.toString()}\\n`\n    })\n\n    return stacks\n  }\n\n  pop(): number {\n    if (this.stacks.length === 0) {\n      throw 'stack set is empty'\n    }\n\n    while (!this.stacks[this.index].top) {\n      this.stacks.pop()\n      this.index--\n\n      if (this.index === -1) {\n        this.index = 0\n        throw 'stack set is empty'\n      }\n    }\n\n    return this.stacks[this.index].pop()\n  }\n\n  push(data: number) {\n    if (this.stacks.length === 0) {\n      this.stacks.push(new Stack())\n      this.push(data)\n    } else if (this.stacks[this.index].length == this.stackCapacity) {\n      this.index++\n      this.stacks.push(new Stack())\n      this.push(data)\n    } else {\n      this.stacks[this.index].push(data)\n    }\n  }\n\n  popAt(i: number): number {\n    if (i >= this.stacks.length) {\n      throw 'index out of bounds'\n    }\n\n    if (!this.stacks[i].top) {\n      throw 'stack is empty'\n    }\n\n    return this.stacks[i].pop()\n  }\n}\n\nexport class Stack {\n  top: Frame\n  length: number\n\n  constructor() {\n    this.top = null\n    this.length = 0\n  }\n\n  toString(): string {\n    const frames: string[] = []\n    let top = this.top\n\n    while (top) {\n      frames.push(top.toString())\n      top = top.next\n    }\n\n    if (frames.length > 0) {\n      const stackStrings = ['top', ...frames, 'bottom']\n      return stackStrings.join(' -> ')\n    }\n\n    return 'empty stack'\n  }\n\n  push(data: number): void {\n    const frame = new Frame(data, this.top)\n    this.top = frame\n    this.length++\n  }\n\n  pop(): number {\n    if (!this.top) {\n      throw 'stack is empty'\n    }\n\n    const frame = this.top\n    this.top = this.top.next\n    this.length--\n\n    return frame.data\n  }\n}\n\nclass Frame {\n  data: number\n  next: Frame\n\n  constructor(data: number, next?: Frame) {\n    this.data = data\n    this.next = next\n  }\n\n  toString(): string {\n    return `[ ${this.data} ]`\n  }\n}\n"
        },
        {
            "description": "Implement a FIFO queue using two LIFO stacks.",
            "go": "package stacks\n\nimport \"fmt\"\n\n// for stack type definition see Stack Set\n\n// Queue is a FIFO data structure implemented using two stacks\ntype Queue struct {\n\tFront Stack\n\tBack  Stack\n}\n\n// ToString provides a string representation for a queue\nfunc (q *Queue) ToString() string {\n\treturn fmt.Sprintf(\"Front: %s\\nBack: %s\\n\", q.Front.ToString(), q.Back.ToString())\n}\n\n// O(n)\nfunc (q *Queue) transfer(source, destination *Stack) {\n\tfor source.Top != nil {\n\t\tdestination.Push(source.Pop())\n\t}\n}\n\n// Add is O(1) without a transfer and O(n) with a transfer\nfunc (q *Queue) Add(data int) {\n\tif q.Back.Top == nil {\n\t\tq.transfer(&q.Front, &q.Back)\n\t}\n\tq.Back.Push(data)\n}\n\n// Remove is O(1) without a transfer and O(n) with a transfer\nfunc (q *Queue) Remove() int {\n\tif q.Front.Top == nil {\n\t\tq.transfer(&q.Back, &q.Front)\n\t\tif q.Front.Top == nil {\n\t\t\tpanic(\"queue is empty\")\n\t\t}\n\t}\n\n\treturn q.Front.Pop()\n}\n",
            "number": "3",
            "python": "from stacks_2 import Stack\n\n# for stack class definition see Stack Set\n\n# reverse one stack into the other as necessary\n# pushing only onto the back stack\n# and popping only from the front stack\n\n\nclass Queue:\n    def __init__(self):\n        self.front = Stack()\n        self.back = Stack()\n\n    def __repr__(self):\n        return f'front: {self.front}\\nback: {self.back}'\n\n    def add(self, data):\n        if not self.back.top:\n            self.transfer(self.front, self.back)\n        self.back.push(data)\n\n    def remove(self):\n        if not self.front.top:\n            self.transfer(self.back, self.front)\n            if not self.front.top:\n                raise Exception('queue is empty')\n\n        return self.front.pop()\n\n    def transfer(self, source, destination):\n        while source.top:\n            destination.push(source.pop())\n",
            "stem": "stacks_3",
            "title": "Queue Via Stacks",
            "ts": "import { Stack } from './stacks_2'\n\nclass Queue {\n  front: Stack\n  back: Stack\n\n  constructor() {\n    this.front = new Stack()\n    this.back = new Stack()\n  }\n\n  toString(): string {\n    return `Front: ${this.front.toString()}\\nBack: ${this.back.toString()}`\n  }\n\n  private transfer(source: Stack, destination: Stack): void {\n    while (source.top) {\n      destination.push(source.pop())\n    }\n  }\n\n  add(data: number): void {\n    if (!this.back.top) {\n      this.transfer(this.front, this.back)\n    }\n    this.back.push(data)\n  }\n\n  remove(): number {\n    if (!this.front.top) {\n      this.transfer(this.back, this.front)\n\n      if (!this.front.top) {\n        throw 'queue is empty'\n      }\n    }\n\n    return this.front.pop()\n  }\n}\n"
        }
    ],
    "Strings": [
        {
            "description": "Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?",
            "go": "package iterables\n\n// IsUnique with access to O(1) lookup data structures O(n)\nfunc IsUnique(s string) bool {\n\tm := map[rune]bool{}\n\tfor _, c := range s {\n\t\tif m[c] {\n\t\t\treturn false\n\t\t}\n\t\tm[c] = true\n\t}\n\treturn true\n}\n\n// IsUniqueSlow without access to any additional data structures O(n^2)\n// could sort in O(n log(n)), but the assumption is that a new string\n// constitutes an additional data structure\nfunc IsUniqueSlow(s string) bool {\n\tfor i, c := range s {\n\t\tfor j := i + 1; j < len(s); j++ {\n\t\t\tif c == rune(s[j]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n",
            "number": "1",
            "python": "# with access to O(1) lookup data structures O(n)\ndef is_unique(s):\n    char_set = set()\n    for c in s:\n        if c in char_set:\n            return False\n        char_set.add(c)\n    return True\n\n\n# without access to any additional data structures O(n^2)\n# could sort in O(n log(n)), but the assumption is that a new string\n# constitutes an additional data structure\ndef is_unique_slow(s):\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                return False\n    return True\n",
            "stem": "strings_1",
            "title": "Is Unique",
            "ts": "// with access to O(1) lookup data structures O(n)\nfunction isUnique(s: string): boolean {\n  const charSet: Set<string> = new Set()\n  for (const c of s) {\n    if (charSet.has(c)) {\n      return false\n    }\n    charSet.add(c)\n  }\n  return true\n}\n\n// without access to any additional data structures O(n^2)\n// could sort in O(n log(n)), but the assumption is that a new string\n// constitutes an additional data structure\nfunction isUniqueSlow(s: string): boolean {\n  let i = 0\n  for (const c of s) {\n    for (let j = i + 1; j < s.length; j++) {\n      if (c === s[j]) {\n        return false\n      }\n    }\n    i++\n  }\n  return true\n}\n"
        },
        {
            "description": "Given two strings, write a method to decide if one is a permutation of the other.",
            "go": "package iterables\n\n// CheckPermutation runs in O(n + m)\nfunc CheckPermutation(s1, s2 string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\n\tcharCount := map[rune]int{}\n\n\tfor _, c := range s1 {\n\t\tif _, ok := charCount[c]; ok {\n\t\t\tcharCount[c]++\n\t\t} else {\n\t\t\tcharCount[c] = 1\n\t\t}\n\t}\n\n\tfor _, c := range s2 {\n\t\tif n, ok := charCount[c]; !ok || n == 0 {\n\t\t\treturn false\n\t\t}\n\t\tcharCount[c]--\n\t}\n\n\treturn true\n}\n",
            "number": "2",
            "python": "# O(n + m)\ndef check_permutation(s1, s2):\n    # need to be of equal length O(1)\n    if len(s1) != len(s2):\n        return False\n\n    # for O(1) lookup\n    char_count = {}\n\n    # O(n) where n is the length of s1\n    for c in s1:\n        if char_count.get(c):\n            char_count[c] += 1\n        else:\n            char_count[c] = 1\n\n    # O(m) where m is the length of s2\n    for c in s2:\n        # relies on 0 being falsy\n        if not char_count.get(c):\n            return False\n        char_count[c] -= 1\n\n    return True\n",
            "stem": "strings_2",
            "title": "Check Permutation",
            "ts": "// O(n + m)\nfunction checkPermutation(s1: string, s2: string): boolean {\n  if (s1.length !== s2.length) {\n    return false\n  }\n\n  const charCount: { [key: string]: number } = {}\n\n  for (const c of s1) {\n    if (charCount[c]) {\n      charCount[c]++\n    } else {\n      charCount[c] = 1\n    }\n  }\n\n  for (const c of s2) {\n    if (!charCount[c]) {\n      return false\n    }\n    charCount[c]--\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Write a method to replace all spaces in a string with '%20'.",
            "go": "package iterables\n\nimport \"strings\"\n\n// URLEncode replaces all spaces with %20\n//could rely on built in replace method, but that seems to be what the problem is asking us to implement\nfunc URLEncode(s string) string {\n\t// amortized cost to append to a slice in Go is O(1) even if O(n) in the worst case\n\tss := []string{}\n\n\t// O(n) where n is the length of the string\n\tfor _, c := range s {\n\t\tif c == ' ' {\n\t\t\tss = append(ss, \"%20\")\n\t\t} else {\n\t\t\t// complexity to cast is O(m) where m is the number of bytes\n\t\t\t// for each rune comprising the string this is effectively O(1)\n\t\t\tss = append(ss, string(c))\n\t\t}\n\t}\n\n\t// strings.Join is O(n)\n\treturn strings.Join(ss, \"\")\n}\n",
            "number": "3",
            "python": "# O(n)\n# could rely on built in replace method, but that seems to be what the problem is asking us to implement\ndef url_encode(s):\n    # strings are immutable so building a list and using ''.join()\n    # is a better approach than building a new string with +=\n\n    # O(n) for the list comprehension and O(n) for join()\n    return ''.join(['%20' if c == ' ' else c for c in s])\n",
            "stem": "strings_3",
            "title": "URL Encode",
            "ts": "// O(n)\n// could rely on built in replace method, but that seems to be what the problem is asking us to implement\nfunction URLEncode(s: string): string {\n  const charArray: string[] = []\n  for (const c of s) {\n    if (c === ' ') {\n      charArray.push('%20')\n    } else {\n      charArray.push(c)\n    }\n  }\n  return charArray.join('')\n}\n"
        },
        {
            "description": "Given a string, write a method to check if it is a permutation of a palindrome.",
            "go": "package iterables\n\n// PalindromePermutation runs in O(n)\nfunc PalindromePermutation(s string) bool {\n\tm := map[rune]int{}\n\n\tfor _, c := range s {\n\t\t// in Go, there is an implied zero value based on type\n\t\t// therefore, you don't need the existence check common in\n\t\t// in other languages before incrementing the count\n\t\tm[c]++\n\t}\n\n\thasOdd := false\n\n\tfor k := range m {\n\t\tif m[k]%2 == 1 {\n\t\t\tif hasOdd {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\thasOdd = true\n\t\t}\n\t}\n\n\treturn true\n}\n",
            "number": "4",
            "python": "# O(n)\ndef palindrome_permutation(s):\n    character_count = {}\n\n    # O(n)\n    for c in s:\n        if character_count.get(c):\n            character_count[c] += 1\n        else:\n            character_count[c] = 1\n\n    # a string is a palindrome if all character counts are even\n    # if any are odd counts, there can be only one serving as the middle character\n\n    has_odd = False\n\n    # number of unique characters is always <= number of characters still O(n)\n    for v in character_count.values():\n        if v % 2 == 1:\n            if has_odd:\n                # more than one odd\n                return False\n            has_odd = True\n\n    return True\n",
            "stem": "strings_4",
            "title": "Palindrome Permutation",
            "ts": "// O(n)\nfunction palindromePermutation(s: string): boolean {\n  const charCount: { [key: string]: number } = {}\n  for (const c of s) {\n    if (charCount[c]) {\n      charCount[c]++\n    } else {\n      charCount[c] = 1\n    }\n  }\n\n  let hasOdd = false\n\n  // Object.values requires a later TS transpilation target than ES6\n  for (const char in charCount) {\n    if (charCount[char] % 2 === 1) {\n      if (hasOdd) {\n        return false\n      }\n      hasOdd = true\n    }\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Write a method to determine if two strings are one edit removed from each other. An edit constitutes replacing, removing or adding a single character.",
            "go": "package iterables\n\n// O(n)\nfunc hasAdditionalCharacter(s1, s2 string) bool {\n\thasSkipped := false\n\ti := 0\n\tj := 0\n\n\tfor i < len(s1) {\n\t\tif s1[i] == s2[j] {\n\t\t\ti++\n\t\t\tj++\n\t\t} else if !hasSkipped {\n\t\t\thasSkipped = true\n\t\t\tj++\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// OneAway runs in O(n)\nfunc OneAway(s1, s2 string) bool {\n\tif len(s2)-len(s1) == 1 {\n\t\treturn hasAdditionalCharacter(s1, s2)\n\t} else if len(s1)-len(s2) == 1 {\n\t\treturn hasAdditionalCharacter(s2, s1)\n\t} else if len(s1) == len(s2) {\n\t\tseenReplacement := false\n\t\tfor i, c := range s1 {\n\t\t\tif c != rune(s2[i]) {\n\t\t\t\tif seenReplacement {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tseenReplacement = true\n\t\t\t}\n\t\t}\n\t\treturn seenReplacement\n\t}\n\treturn false\n}\n",
            "number": "5",
            "python": "# O(n) determines if s2 is s1 with an additional character\ndef has_additional_character(s1, s2):\n    # can skip a single additional character in s2 to create s1\n    has_skipped = False\n    i = 0\n    j = 0\n\n    while i < len(s1):\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        elif not has_skipped:\n            has_skipped = True\n            j += 1\n        else:\n            return False\n\n    return True\n\n\n# O(n)\ndef one_away(s1, s2):\n    # O(n) add case\n    if len(s2) - len(s1) == 1:\n        return has_additional_character(s1, s2)\n\n    # O(n) remove case\n    elif len(s1) - len(s2) == 1:\n        return has_additional_character(s2, s1)\n\n    # O(n) handle replace\n    elif len(s1) == len(s2):\n        # can have at most one replacement\n        seen_replacement = False\n\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                if seen_replacement:\n                    return False\n                seen_replacement = True\n\n        # will be False if strings are identical\n        return seen_replacement\n\n    # if string lengths differ by more than 1\n    return False\n",
            "stem": "strings_5",
            "title": "One Away",
            "ts": "// O(n)\nfunction hasAdditionalCharacter(s1: string, s2: string): boolean {\n  let hasSkipped = false\n  let i = 0\n  let j = 0\n\n  while (i < s1.length) {\n    if (s1[i] == s2[j]) {\n      i++\n      j++\n    } else if (!hasSkipped) {\n      hasSkipped = true\n      j++\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\n// O(n)\nfunction oneAway(s1: string, s2: string): boolean {\n  if (s2.length - s1.length === 1) {\n    return hasAdditionalCharacter(s1, s2)\n  } else if (s1.length - s2.length === 1) {\n    return hasAdditionalCharacter(s2, s1)\n  } else if (s1.length === s2.length) {\n    let seenReplacement = false\n    for (let i = 0; i < s1.length; i++) {\n      if (s1[i] !== s2[i]) {\n        if (seenReplacement) {\n          return false\n        }\n        seenReplacement = true\n      }\n    }\n    return seenReplacement\n  }\n  return false\n}\n"
        },
        {
            "description": "Implement a method to perform basic string compression using the counts of repeated characters. For example, \"aabcccccaaa\" => \"s2b1c5a3\". If the compressed string would not be smaller, your method should return the original string. Assume the string fits the pattern [a-zA-Z]*.",
            "go": "package iterables\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CompressString runs in O(n)\nfunc CompressString(s string) string {\n\t// handle empty string\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\n\tss := []string{}\n\tstartIndex := 0\n\tcurrentIndex := 0\n\tcurrentChar := rune(s[0])\n\n\t// O(n)\n\tfor _, c := range s {\n\t\tif c != currentChar {\n\t\t\tss = append(ss, []string{string(currentChar), strconv.Itoa(currentIndex - startIndex)}...)\n\t\t\tstartIndex = currentIndex\n\t\t\tcurrentChar = c\n\t\t}\n\t\tcurrentIndex++\n\t}\n\n\t// handle the final character sequence\n\tss = append(ss, []string{string(currentChar), strconv.Itoa(currentIndex - startIndex)}...)\n\n\tif len(ss) < len(s) {\n\t\t// O(n)\n\t\treturn strings.Join(ss, \"\")\n\t}\n\n\treturn s\n}\n",
            "number": "6",
            "python": "# O(n)\ndef compress_string(s):\n    # handle edge case ahead of assignment to s[0]\n    if s == '':\n        return ''\n\n    # accumulator list to store compressed string\n    acc = []\n\n    start_index = 0\n    current_index = 0\n    current_char = s[0]\n\n    # O(n)\n    for c in s:\n        if c != current_char:\n            # O(1)\n            acc.extend([current_char, str(current_index - start_index)])\n            start_index = current_index\n            current_char = c\n        current_index += 1\n\n    acc.extend([current_char, str(current_index - start_index)])\n\n    # O(n)\n    return ''.join(acc) if len(acc) < len(s) else s\n",
            "stem": "strings_6",
            "title": "String Compression",
            "ts": "// O(n)\nfunction compressString(s: string): string {\n  if (s === '') {\n    return ''\n  }\n\n  const acc: string[] = []\n  let startIndex = 0\n  let currentIndex = 0\n  let currentChar = s[0]\n\n  for (const c of s) {\n    if (c !== currentChar) {\n      acc.push(currentChar, '' + (currentIndex - startIndex))\n      startIndex = currentIndex\n      currentChar = c\n    }\n    currentIndex++\n  }\n\n  acc.push(currentChar, '' + (currentIndex - startIndex))\n\n  return acc.length > s.length ? s : acc.join('')\n}\n"
        },
        {
            "description": "Using the built in language specific string method for isSubstring and given two strings, s1 and s2, check if s2 is a rotation of s1 using only a single call to isSubstring. (e.g. \"arfoob\" is a rotation of \"foobar\")",
            "go": "package iterables\n\nimport \"strings\"\n\n// IsRotation runs in O(n)\nfunc IsRotation(s1, s2 string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\n\treturn strings.Contains(s2+s2, s1)\n}\n",
            "number": "7",
            "python": "# O(n)\ndef is_rotation(s1, s2):\n    if len(s1) != len(s2):\n        return False\n\n    # let AB represent s1\n    # where A is the first part of the string and B is the second\n    # s2 is a rotation <=> s2 == BA (necessary and sufficient)\n    # let s2 concatenated be represented by BABA\n    # if s1 can be represented by AB then it must be a substring of s2 + s2\n\n    # O(n)\n    return s1 in s2 + s2\n",
            "stem": "strings_7",
            "title": "String Rotation",
            "ts": "// O(n)\nfunction isRotation(s1: string, s2: string): boolean {\n  if (s1.length !== s2.length) {\n    return false\n  }\n\n  return (s2 + s2).includes(s1)\n}\n"
        }
    ]
}