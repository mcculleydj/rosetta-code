{
    "Iterables": [
        {
            "description": "Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?",
            "go": "package iterables\n\n// IsUnique with access to O(1) lookup data structures O(n)\nfunc IsUnique(s string) bool {\n\tm := map[rune]bool{}\n\tfor _, c := range s {\n\t\tif m[c] {\n\t\t\treturn false\n\t\t}\n\t\tm[c] = true\n\t}\n\treturn true\n}\n\n// IsUniqueSlow without access to any additional data structures O(n^2)\n// could sort in O(n log(n)), but the assumption is that a new string\n// constitutes an additional data structure\nfunc IsUniqueSlow(s string) bool {\n\tfor i, c := range s {\n\t\tfor j := i + 1; j < len(s); j++ {\n\t\t\tif c == rune(s[j]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n",
            "number": "1",
            "python": "# with access to O(1) lookup data structures O(n)\ndef is_unique(s):\n    char_set = set()\n    for c in s:\n        if c in char_set:\n            return False\n        char_set.add(c)\n    return True\n\n\n# without access to any additional data structures O(n^2)\n# could sort in O(n log(n)), but the assumption is that a new string\n# constitutes an additional data structure\ndef is_unique_slow(s):\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                return False\n    return True\n",
            "stem": "iterables_1",
            "title": "Is Unique",
            "ts": "// with access to O(1) lookup data structures O(n)\nfunction isUnique(s: string): boolean {\n  const charSet: Set<string> = new Set()\n  for (const c of s) {\n    if (charSet.has(c)) {\n      return false\n    }\n    charSet.add(c)\n  }\n  return true\n}\n\n// without access to any additional data structures O(n^2)\n// could sort in O(n log(n)), but the assumption is that a new string\n// constitutes an additional data structure\nfunction isUniqueSlow(s: string): boolean {\n  let i = 0\n  for (const c of s) {\n    for (let j = i + 1; j < s.length; j++) {\n      if (c === s[j]) {\n        return false\n      }\n    }\n    i++\n  }\n  return true\n}\n"
        },
        {
            "description": "Given two strings, write a method to decide if one is a permutation of the other.",
            "go": "package iterables\n\n// CheckPermutation runs in O(n + m)\nfunc CheckPermutation(s1, s2 string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\n\tcharCount := map[rune]int{}\n\n\tfor _, c := range s1 {\n\t\tif _, ok := charCount[c]; ok {\n\t\t\tcharCount[c]++\n\t\t} else {\n\t\t\tcharCount[c] = 1\n\t\t}\n\t}\n\n\tfor _, c := range s2 {\n\t\tif n, ok := charCount[c]; !ok || n == 0 {\n\t\t\treturn false\n\t\t}\n\t\tcharCount[c]--\n\t}\n\n\treturn true\n}\n",
            "number": "2",
            "python": "# O(n + m)\ndef check_permutation(s1, s2):\n    # need to be of equal length O(1)\n    if len(s1) != len(s2):\n        return False\n\n    # for O(1) lookup\n    char_count = {}\n\n    # O(n) where n is the length of s1\n    for c in s1:\n        if char_count.get(c):\n            char_count[c] += 1\n        else:\n            char_count[c] = 1\n\n    # O(m) where m is the length of s2\n    for c in s2:\n        # relies on 0 being falsy\n        if not char_count.get(c):\n            return False\n        char_count[c] -= 1\n\n    return True\n",
            "stem": "iterables_2",
            "title": "Check Permutation",
            "ts": "// O(n + m)\nfunction checkPermutation(s1: string, s2: string): boolean {\n  if (s1.length !== s2.length) {\n    return false\n  }\n\n  const charCount: { [key: string]: number } = {}\n\n  for (const c of s1) {\n    if (charCount[c]) {\n      charCount[c]++\n    } else {\n      charCount[c] = 1\n    }\n  }\n\n  for (const c of s2) {\n    if (!charCount[c]) {\n      return false\n    }\n    charCount[c]--\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Write a method to replace all spaces in a string with '%20'.",
            "go": "package iterables\n\nimport \"strings\"\n\n// URLEncode replaces all spaces with %20\n//could rely on built in replace method, but that seems to be what the problem is asking us to implement\nfunc URLEncode(s string) string {\n\t// amortized cost to append to a slice in Go is O(1) even if O(n) in the worst case\n\tss := []string{}\n\n\t// O(n) where n is the length of the string\n\tfor _, c := range s {\n\t\tif c == ' ' {\n\t\t\tss = append(ss, \"%20\")\n\t\t} else {\n\t\t\t// complexity to cast is O(m) where m is the number of bytes\n\t\t\t// for each rune comprising the string this is effectively O(1)\n\t\t\tss = append(ss, string(c))\n\t\t}\n\t}\n\n\t// strings.Join is O(n)\n\treturn strings.Join(ss, \"\")\n}\n",
            "number": "3",
            "python": "# O(n)\n# could rely on built in replace method, but that seems to be what the problem is asking us to implement\ndef url_encode(s):\n    # strings are immutable so building a list and using ''.join()\n    # is a better approach than building a new string with +=\n\n    # O(n) for the list comprehension and O(n) for join()\n    return ''.join(['%20' if c == ' ' else c for c in s])\n",
            "stem": "iterables_3",
            "title": "URL Encode",
            "ts": "// O(n)\n// could rely on built in replace method, but that seems to be what the problem is asking us to implement\nfunction URLEncode(s: string): string {\n  const charArray: string[] = []\n  for (const c of s) {\n    if (c === ' ') {\n      charArray.push('%20')\n    } else {\n      charArray.push(c)\n    }\n  }\n  return charArray.join('')\n}\n"
        },
        {
            "description": "Given a string, write a method to check if it is a permutation of a palindrome.",
            "go": "package iterables\n\n// PalindromePermutation runs in O(n)\nfunc PalindromePermutation(s string) bool {\n\tm := map[rune]int{}\n\n\tfor _, c := range s {\n\t\t// in Go, there is an implied zero value based on type\n\t\t// therefore, you don't need the existence check common in\n\t\t// in other languages before incrementing the count\n\t\tm[c]++\n\t}\n\n\thasOdd := false\n\n\tfor k := range m {\n\t\tif m[k]%2 == 1 {\n\t\t\tif hasOdd {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\thasOdd = true\n\t\t}\n\t}\n\n\treturn true\n}\n",
            "number": "4",
            "python": "# O(n)\ndef palindrome_permutation(s):\n    character_count = {}\n\n    # O(n)\n    for c in s:\n        if character_count.get(c):\n            character_count[c] += 1\n        else:\n            character_count[c] = 1\n\n    # a string is a palindrome if all character counts are even\n    # if any are odd counts, there can be only one serving as the middle character\n\n    has_odd = False\n\n    # number of unique characters is always <= number of characters still O(n)\n    for v in character_count.values():\n        if v % 2 == 1:\n            if has_odd:\n                # more than one odd\n                return False\n            has_odd = True\n\n    return True\n",
            "stem": "iterables_4",
            "title": "Palindrome Permutation",
            "ts": "// O(n)\nfunction palindromePermutation(s: string): boolean {\n  const charCount: { [key: string]: number } = {}\n  for (const c of s) {\n    if (charCount[c]) {\n      charCount[c]++\n    } else {\n      charCount[c] = 1\n    }\n  }\n\n  let hasOdd = false\n\n  // Object.values requires a later TS transpilation target than ES6\n  for (const char in charCount) {\n    if (charCount[char] % 2 === 1) {\n      if (hasOdd) {\n        return false\n      }\n      hasOdd = true\n    }\n  }\n\n  return true\n}\n"
        },
        {
            "description": "Write a method to determine if two strings are one edit removed from each other. An edit constitutes replacing, removing or adding a single character.",
            "go": "package iterables\n\n// O(n)\nfunc hasAdditionalCharacter(s1, s2 string) bool {\n\thasSkipped := false\n\ti := 0\n\tj := 0\n\n\tfor i < len(s1) {\n\t\tif s1[i] == s2[j] {\n\t\t\ti++\n\t\t\tj++\n\t\t} else if !hasSkipped {\n\t\t\thasSkipped = true\n\t\t\tj++\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// OneAway runs in O(n)\nfunc OneAway(s1, s2 string) bool {\n\tif len(s2)-len(s1) == 1 {\n\t\treturn hasAdditionalCharacter(s1, s2)\n\t} else if len(s1)-len(s2) == 1 {\n\t\treturn hasAdditionalCharacter(s2, s1)\n\t} else if len(s1) == len(s2) {\n\t\tseenReplacement := false\n\t\tfor i, c := range s1 {\n\t\t\tif c != rune(s2[i]) {\n\t\t\t\tif seenReplacement {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tseenReplacement = true\n\t\t\t}\n\t\t}\n\t\treturn seenReplacement\n\t}\n\treturn false\n}\n",
            "number": "5",
            "python": "# O(n) determines if s2 is s1 with an additional character\ndef has_additional_character(s1, s2):\n    # can skip a single additional character in s2 to create s1\n    has_skipped = False\n    i = 0\n    j = 0\n\n    while i < len(s1):\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        elif not has_skipped:\n            has_skipped = True\n            j += 1\n        else:\n            return False\n\n    return True\n\n\n# O(n)\ndef one_away(s1, s2):\n    # O(n) add case\n    if len(s2) - len(s1) == 1:\n        return has_additional_character(s1, s2)\n\n    # O(n) remove case\n    elif len(s1) - len(s2) == 1:\n        return has_additional_character(s2, s1)\n\n    # O(n) handle replace\n    elif len(s1) == len(s2):\n        # can have at most one replacement\n        seen_replacement = False\n\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                if seen_replacement:\n                    return False\n                seen_replacement = True\n\n        # will be False if strings are identical\n        return seen_replacement\n\n    # if string lengths differ by more than 1\n    return False\n",
            "stem": "iterables_5",
            "title": "One Away",
            "ts": "// O(n)\nfunction hasAdditionalCharacter(s1: string, s2: string): boolean {\n  let hasSkipped = false\n  let i = 0\n  let j = 0\n\n  while (i < s1.length) {\n    if (s1[i] == s2[j]) {\n      i++\n      j++\n    } else if (!hasSkipped) {\n      hasSkipped = true\n      j++\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\n// O(n)\nfunction oneAway(s1: string, s2: string): boolean {\n  if (s2.length - s1.length === 1) {\n    return hasAdditionalCharacter(s1, s2)\n  } else if (s1.length - s2.length === 1) {\n    return hasAdditionalCharacter(s2, s1)\n  } else if (s1.length === s2.length) {\n    let seenReplacement = false\n    for (let i = 0; i < s1.length; i++) {\n      if (s1[i] !== s2[i]) {\n        if (seenReplacement) {\n          return false\n        }\n        seenReplacement = true\n      }\n    }\n    return seenReplacement\n  }\n  return false\n}\n"
        },
        {
            "description": "Implement a method to perform basic string compression using the counts of repeated characters. For example, \"aabcccccaaa\" => \"s2b1c5a3\". If the compressed string would not be smaller, your method should return the original string. Assume the string fits the pattern [a-zA-Z]*.",
            "go": "package iterables\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CompressString runs in O(n)\nfunc CompressString(s string) string {\n\t// handle empty string\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\n\tss := []string{}\n\tstartIndex := 0\n\tcurrentIndex := 0\n\tcurrentChar := rune(s[0])\n\n\t// O(n)\n\tfor _, c := range s {\n\t\tif c != currentChar {\n\t\t\tss = append(ss, []string{string(currentChar), strconv.Itoa(currentIndex - startIndex)}...)\n\t\t\tstartIndex = currentIndex\n\t\t\tcurrentChar = c\n\t\t}\n\t\tcurrentIndex++\n\t}\n\n\t// handle the final character sequence\n\tss = append(ss, []string{string(currentChar), strconv.Itoa(currentIndex - startIndex)}...)\n\n\tif len(ss) < len(s) {\n\t\t// O(n)\n\t\treturn strings.Join(ss, \"\")\n\t}\n\n\treturn s\n}\n",
            "number": "6",
            "python": "# O(n)\ndef compress_string(s):\n    # handle edge case ahead of assignment to s[0]\n    if s == '':\n        return ''\n\n    # accumulator list to store compressed string\n    acc = []\n\n    start_index = 0\n    current_index = 0\n    current_char = s[0]\n\n    # O(n)\n    for c in s:\n        if c != current_char:\n            # O(1)\n            acc.extend([current_char, str(current_index - start_index)])\n            start_index = current_index\n            current_char = c\n        current_index += 1\n\n    acc.extend([current_char, str(current_index - start_index)])\n\n    # O(n)\n    return ''.join(acc) if len(acc) < len(s) else s\n",
            "stem": "iterables_6",
            "title": "String Compression",
            "ts": "// O(n)\nfunction compressString(s: string): string {\n  if (s === '') {\n    return ''\n  }\n\n  const acc: string[] = []\n  let startIndex = 0\n  let currentIndex = 0\n  let currentChar = s[0]\n\n  for (const c of s) {\n    if (c !== currentChar) {\n      acc.push(currentChar, '' + (currentIndex - startIndex))\n      startIndex = currentIndex\n      currentChar = c\n    }\n    currentIndex++\n  }\n\n  acc.push(currentChar, '' + (currentIndex - startIndex))\n\n  return acc.length > s.length ? s : acc.join('')\n}\n\nconsole.log(compressString('aabcccccaaa'))\n"
        },
        {
            "description": "Given an image represented by an NxN matrix where each pixel is encoded as an integer, write a method to perform a 90 degree rotation in place (i.e. do not create a new matrix).",
            "go": "package iterables\n\n// RotateMatrix runs in O(n^2)\nfunc RotateMatrix(m [][]int) {\n\tfor i := 0; i < len(m)/2; i++ {\n\t\tfor j := i; j < len(m)-i-1; j++ {\n\t\t\t// slices are pointers to underlying arrays\n\t\t\t// so while everything is Go is pass by value, this is already\n\t\t\t// a reference and the modifications will occur in place\n\t\t\trotateCell(m, m[i][j], [2]int{j, len(m) - i - 1}, [2]int{i, j})\n\t\t}\n\t}\n}\n\nfunc rotateCell(m [][]int, value int, destination, start [2]int) {\n\tpreviousValue := m[destination[0]][destination[1]]\n\tm[destination[0]][destination[1]] = value\n\n\t// base case\n\tif destination[0] == start[0] && destination[1] == start[1] {\n\t\treturn\n\t}\n\n\trotateCell(m, previousValue, [2]int{destination[1], len(m) - destination[0] - 1}, start)\n}\n",
            "number": "7",
            "python": "# O(n^2) for an n x n matrix\ndef rotate_matrix(m):\n    # given a cell (i, j) the destination cell is (j, n - i - 1) for an n x n matrix\n\n    # assume m is represented by a 2D list of integers\n    # nested for loop is O(n^2)\n    # in this loop \"i\" represents the layer\n    # in an n x n matrix there are floor(n / 2) layers to rotate\n    for i in range(len(m) // 2):\n        for j in range(i, len(m) - i - 1):\n            # results in 4 recursive calls\n            rotate_cell(m, m[i][j], (j, len(m) - i - 1), (i, j))\n\n\n# rotate_cell is a recursive helper that sets the value of\n# of the destination cell to the supplied value\n# rotate_cell will be called 4 times before destination == start\ndef rotate_cell(m, value, destination, start):\n    previous_value = m[destination[0]][destination[1]]\n    m[destination[0]][destination[1]] = value\n\n    # base case\n    if destination == start:\n        return\n\n    rotate_cell(m, previous_value,\n                (destination[1], len(m) - destination[0] - 1), start)\n",
            "stem": "iterables_7",
            "title": "Matrix Rotation",
            "ts": "// O(n^2)\nfunction rotateMatrix(m: number[][]) {\n  // nested loop is O(n^2)\n  for (let i = 0; i < Math.floor(m.length / 2); i++) {\n    for (let j = i; j < m.length - i - 1; j++) {\n      rotateCell(m, m[i][j], [j, m.length - i - 1], [i, j])\n    }\n  }\n}\n\n// O(1) for each rotation with 4 recursive calls\nfunction rotateCell(\n  m: number[][],\n  value: number,\n  destination: number[],\n  start: number[],\n) {\n  const previousValue = m[destination[0]][destination[1]]\n  m[destination[0]][destination[1]] = value\n\n  if (destination[0] === start[0] && destination[1] === start[1]) {\n    return\n  }\n\n  rotateCell(\n    m,\n    previousValue,\n    [destination[1], m.length - destination[0] - 1],\n    start,\n  )\n}\n"
        },
        {
            "description": "Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.",
            "go": "package iterables\n\n// ZeroMatrix runs in O(nm)\nfunc ZeroMatrix(m [][]int) {\n\tzeroRows := map[int]bool{}\n\tzeroColumns := map[int]bool{}\n\n\tfor i := 0; i < len(m); i++ {\n\t\tfor j := 0; j < len(m[0]); j++ {\n\t\t\tif m[i][j] == 0 {\n\t\t\t\tzeroRows[i] = true\n\t\t\t\tzeroColumns[j] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := 0; i < len(m); i++ {\n\t\tfor j := 0; j < len(m[0]); j++ {\n\t\t\tif zeroRows[i] || zeroRows[j] {\n\t\t\t\tm[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n}\n",
            "number": "8",
            "python": "# O(mn) where m and n are the dimensions of the matrix\ndef zero_matrix(m):\n    zero_rows = set()\n    zero_columns = set()\n\n    # O(mn)\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            if m[i][j] == 0:\n                zero_rows.add(i)\n                zero_columns.add(j)\n    # O(mn)\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            # O(1) lookup by using sets\n            if i in zero_rows or j in zero_columns:\n                m[i][j] = 0\n\n\nm = [\n    [1, 2, 3],\n    [1, 0, 3],\n    [1, 2, 3]\n]\nzero_matrix(m)\nprint(m)\n",
            "stem": "iterables_8",
            "title": "Zero Matrix",
            "ts": "// O(mn)\nfunction zeroMatrix(m: number[][]) {\n  const zeroRows: Set<number> = new Set()\n  const zeroColumns: Set<number> = new Set()\n\n  for (let i = 0; i < m.length; i++) {\n    for (let j = 0; j < m[0].length; j++) {\n      if (m[i][j] === 0) {\n        zeroRows.add(i)\n        zeroColumns.add(j)\n      }\n    }\n  }\n\n  for (let i = 0; i < m.length; i++) {\n    for (let j = 0; j < m[0].length; j++) {\n      if (zeroRows.has(i) || zeroColumns.has(j)) {\n        m[i][j] = 0\n      }\n    }\n  }\n}\n"
        },
        {
            "description": "Using the built in language specific string method for isSubstring and given two strings, s1 and s2, check if s2 is a rotation of s1 using only a single call to isSubstring. (e.g. \"arfoob\" is a rotation of \"foobar\")",
            "go": "package iterables\n\nimport \"strings\"\n\n// IsRotation runs in O(n)\nfunc IsRotation(s1, s2 string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\n\treturn strings.Contains(s2+s2, s1)\n}\n",
            "number": "9",
            "python": "# O(n)\ndef is_rotation(s1, s2):\n    if len(s1) != len(s2):\n        return False\n\n    # let AB represent s1\n    # where A is the first part of the string and B is the second\n    # s2 is a rotation <=> s2 == BA (necessary and sufficient)\n    # let s2 concatenated be represented by BABA\n    # if s1 can be represented by AB then it must be a substring of s2 + s2\n\n    # O(n)\n    return s1 in s2 + s2\n",
            "stem": "iterables_9",
            "title": "String Rotation",
            "ts": "// O(n)\nfunction isRotation(s1: string, s2: string): boolean {\n  if (s1.length !== s2.length) {\n    return false\n  }\n\n  return (s2 + s2).includes(s1)\n}\n"
        }
    ],
    "Linked Lists": [
        {
            "description": "Write a method to remove duplicates from an unsorted linked list. As a follow up write a method that does so without any additional memory allocation like storing the seen values in a hash table.",
            "go": "package linked\n\nimport \"fmt\"\n\n// Node is a node in a linked list\n// value could be any datatype, but Go does not support generics\ntype Node struct {\n\tValue int\n\tNext  *Node\n}\n\n// List wraps a head node\ntype List struct {\n\tHead *Node\n}\n\n// ToString prints a linked list\nfunc (l List) ToString() string {\n\ts := \"\"\n\tnode := l.Head\n\tfor node != nil {\n\t\ts = s + fmt.Sprintf(\"%d -> \", node.Value)\n\t\tnode = node.Next\n\t}\n\treturn s + \"nil\"\n}\n\n// RemoveDuplicatesTime runs in O(n)\nfunc RemoveDuplicatesTime(l List) {\n\tvalueSet := map[int]bool{}\n\tnode := l.Head\n\n\tfor node.Next != nil {\n\t\tif valueSet[node.Next.Value] {\n\t\t\tnode.Next = node.Next.Next\n\t\t} else {\n\t\t\tvalueSet[node.Next.Value] = true\n\t\t\tnode = node.Next\n\t\t}\n\t}\n}\n\n// RemoveDuplicatesSpace runs in O(1) space -- O(n^2) time\nfunc RemoveDuplicatesSpace(l List) {\n\tindexNode := l.Head\n\tvar cursorNode *Node\n\n\tfor indexNode.Next != nil {\n\t\tcursorNode = indexNode\n\t\tfor cursorNode.Next != nil {\n\t\t\tif cursorNode.Next.Value == indexNode.Value {\n\t\t\t\tcursorNode.Next = cursorNode.Next.Next\n\t\t\t} else {\n\t\t\t\tcursorNode = cursorNode.Next\n\t\t\t}\n\t\t}\n\t\tindexNode = indexNode.Next\n\t}\n}\n",
            "number": "1",
            "python": "class LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def __repr__(self):\n        node = self.head\n        nodes = []\n        while node is not None:\n            nodes.append(str(node.value))\n            node = node.next\n        nodes.append('None')\n        return \" -> \".join(nodes)\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n    def __repr__(self):\n        return str(self.value)\n\n\n# O(n)\ndef remove_duplicates_time(linked_list):\n    values = set()\n    node = linked_list.head\n\n    while node.next != None:\n        if node.next.value in values:\n            node.next = node.next.next\n        else:\n            values.add(node.next.value)\n            node = node.next\n\n\n# O(1) space -- O(n^2) time\ndef remove_duplicates_space(linked_list):\n    index_node = linked_list.head\n\n    while index_node.next != None:\n        cursor_node = index_node\n        while cursor_node.next != None:\n            if cursor_node.next.value == index_node.value:\n                cursor_node.next = cursor_node.next.next\n            else:\n                cursor_node = cursor_node.next\n        index_node = index_node.next\n\n\nll = LinkedList()\n\nn1 = Node(1)\nn2 = Node(2)\nn3 = Node(3)\nn4 = Node(4)\nn5 = Node(4)\nn6 = Node(5)\nn7 = Node(5)\n\nll.head = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\nn4.next = n5\nn5.next = n6\nn6.next = n7\n\nprint(ll)\nremove_duplicates_time(ll)\n# remove_duplicates_space(ll)\nprint(ll)\n",
            "stem": "linked_lists_1",
            "title": "Remove Duplicates",
            "ts": "// Node already exists in JS\nclass Node_ {\n  value: number\n  next: Node_\n\n  constructor(value: number, next: Node_) {\n    this.value = value\n    this.next = next\n  }\n}\n\nclass LinkedList {\n  head: Node_\n\n  constructor(head: Node_) {\n    this.head = head\n  }\n\n  toString() {\n    let s = ''\n    let node = this.head\n    while (node) {\n      s = `${s}${node.value} -> `\n      node = node.next\n    }\n    return s + 'nil'\n  }\n}\n\n// O(n)\nfunction removeDuplicatesTime(l: LinkedList) {\n  const valueSet: Set<number> = new Set()\n  let node = l.head\n\n  while (node.next) {\n    if (valueSet.has(node.next.value)) {\n      node.next = node.next.next\n    } else {\n      valueSet.add(node.next.value)\n      node = node.next\n    }\n  }\n}\n\n// O(1) space -- O(n^2) time\nfunction removeDuplicatesSpace(l: LinkedList) {\n  let indexNode = l.head\n  let cursorNode\n\n  while (indexNode.next) {\n    cursorNode = indexNode\n    while (cursorNode.next) {\n      if (cursorNode.next.value === indexNode.value) {\n        cursorNode.next = cursorNode.next.next\n      } else {\n        cursorNode = cursorNode.next\n      }\n    }\n    indexNode = indexNode.next\n  }\n}\n"
        }
    ]
}